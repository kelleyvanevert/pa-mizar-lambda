::: # Lambda calculus

::: Original files:
:::  [.abs](text/lambda.abs),
:::  [.miz](text/lambda.miz),
:::  [.voc](dict/lambda.voc)

::: @TOC

::: TODO note how we almost never work by inductive/recursive means,
:::  in constract with, say, Coq.

:: Environ originally taken from `finseq_2`. Later, I added trees and orders.
environ

  :: Vocabularies are basically for Mizar's lexer.
  vocabularies LAMBDA,
    FINSET_1,
    NUMBERS,
    NAT_1, XBOOLE_0, SUBSET_1, FINSEQ_1, XXREAL_0, CARD_1,
    ARYTM_1, ARYTM_3, TARSKI, ORDINAL4, FUNCOP_1,
    RELAT_2, RELAT_1,
    FUNCT_1, FUNCT_2,
    ZFMISC_1, PARTFUN1,
    ORDERS_2, ORDERS_1,
    FINSEQ_2, PBOOLE, CARD_3, VALUED_1,
    TREES_4, TREES_3, TREES_2, TREES_1;
  
  :: Radix type specifications
  :: But it also helped [175 unknown attribute format] error with [finite set]
  notations FINSET_1,
    TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1,
    NUMBERS, XCMPLX_0, DOMAIN_1, NAT_1, RELAT_1, PARTFUN1,
    RELAT_2, RELSET_1,
    FUNCT_1, FUNCT_2,
    FUNCT_3, FINSEQ_1, FINSEQ_2, BINOP_1, PBOOLE, FUNCOP_1, CARD_3,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ORDERS_1, ORDERS_2,
    XXREAL_0, VALUED_1,
    RECDEF_1;

  :: For modes? (unknown mode format resolved)
  constructors RELAT_2, RELAT_1,
    PARTFUN1, BINOP_1, DOMAIN_1,
    FUNCT_1, FUNCT_2, FUNCT_3,
    FUNCOP_1,
    RELSET_1,
    SQUARE_1, NAT_1, FINSEQ_1, FINSEQ_2, PBOOLE, CARD_3, VALUED_1, SETFAM_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ORDERS_1, ORDERS_2,
    RECDEF_1,
    FINSET_1,
    ENUMSET1,
    WELLORD2;

  :: Definition are for automatically unfolding predicates
  ::  in the thesis you are proving
  definitions TARSKI,
    FUNCT_1, FUNCT_2,
    FINSEQ_1, CARD_1, PBOOLE, FUNCOP_1,
    ORDERS_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ::XTUPLE_0;
    MCART_1; ::, FUNCT_5, RECDEF_1;

  :: Registrations are for clusters (showing that a type exists (is non-empty),
  ::  and automatically adding adjectives)
  registrations XBOOLE_0, SUBSET_1, ORDINAL1, PARTFUN1,
    ::RELAT_2,
    RELAT_1,
    FUNCT_1, FUNCT_2,
    FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, FINSEQ_2, CARD_1, RELSET_1,
    PBOOLE, CARD_3,
    ORDERS_2,
    TREES_4, TREES_3, TREES_2, TREES_1,
    FINSET_1;

  :: Load theorem en definition labels
  theorems FUNCOP_1, RELAT_1, TARSKI, FINSEQ_1, FINSEQ_2,
    ::XTUPLE_0,
    MCART_1, FUNCT_5, :: RECDEF_1,
    FUNCT_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    XBOOLE_0, SUBSET_1, RELAT_2, ENUMSET1,
    CARD_1, CARD_2, CARD_3, CARD_4;
  
  schemes RECDEF_1, TREES_2;

  requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

begin

::: ## Syntax and behaviour

reserve T,T1,T2 for Tree,
        D for DecoratedTree,
        p,q,q2,r for FinSequence of NAT,
        x,y,X,Y for set,
        i,j,k,l,m,n for Element of NAT;

::: ### Lambda terms

::: A _lambda term_ is identified with it's AST (abstract
:::  syntax tree). More precisely, we identify a lambda term
:::  with a finite decorated tree.
::: The nodes of the tree denote either application, abstraction
:::  or a variable. Using _De Bruijn_ variable indexing, we decorate
:::  variables with their De Bruijn index (a natural nuber). Note
:::  that we needn't explicitly annotate the type of a node,
:::  as the three types of nodes differ in how many children they must
:::  have: an application always has two children, an abstraction but one,
:::  and variables don't have any. So it suffices to decorate application
:::  and abstraction nodes with some default value (say, $0$).

::: In Mizar, a `Tree` is a non-empty subset of `NAT*`, so a set of finite
:::  sequences of natural numbers, such that certain logical properties hold.
::: Every such sequence denotes a node in the tree, and can be interpreted
:::  as a _path specification_ (how to get there, from the top). We see, then,
:::  that lambda term trees are a specific subset of general trees, in which
:::  only finite sequences of $\\{0,1\\}$ are used to denote nodes, nodes
:::  with children are decorated with a $0$, and is also finite in height.
::: By _decorating_ a node `r` with a number `n`, we mean that `M.r = n`.
::: Here `M` is the `DecoratedTree of NAT` which represents the lambda term.

definition
  let D;
  
  attr D is LambdaTerm-like means
    :Def1:
    dom D is finite &
    for r st r in dom D holds
      r is FinSequence of {0,1} &
      (r^<*0*> in dom D implies D.r = 0);
end;

::: Some simple `LambdaTerm-like` things.

::: TODO: some more of these simple trees, for easy usage
:::  later on, when defining application and abstraction.

registration
  cluster { {} } --> 0 -> LambdaTerm-like;
  coherence
  proof
    set D = { {} } --> 0;
    dom D = { {} } by FUNCOP_1:13;
    hence dom D is finite;
    let r be FinSequence of NAT;
    assume
  A1: r in dom D;
    dom D = { {} } by FUNCOP_1:13;
    then r = {} by A1, TARSKI:def 1;
    then r = <*> {0,1} by FINSEQ_1:def 6;
    hence r is FinSequence of {0,1};
    assume r^<*0*> in dom D;
    thus D.r = 0 by A1, FUNCOP_1:7;
  end;
end;

registration
  cluster { <*> NAT } -> Tree-like;
  coherence
  proof
    { <*> NAT } = { {} } by FINSEQ_1:def 6;
    thus { <*> NAT } is Tree-like;
  end;
end;

registration
  cluster { <*> NAT } --> 0 -> LambdaTerm-like;
  coherence
  proof
    { <*> NAT } = { {} } by FINSEQ_1:def 6;
    thus { <*> NAT } --> 0 is LambdaTerm-like;
  end;
end;

registration
  cluster { {}, <*0*> } -> Tree-like;
  coherence
  proof
    set T = { {}, <*0*> };
    T = elementary_tree 1 by TREES_1:51;
    then reconsider T as Tree;
    T is Tree-like;
    hence { {}, <*0*> } is Tree-like;
  end;
end;

registration
  cluster { {}, <*0*> } --> 0 -> LambdaTerm-like;
  coherence
  proof
    set T = { {}, <*0*> };
  A6: T is finite;
    set D = T --> 0;
  A2: dom D = T by FUNCOP_1:13;
    hence dom D is finite by A6;
    reconsider T as Tree;
    let r be FinSequence of NAT;
    assume
  A1: r in dom D;
    then
  A3: r = {} or r = <*0*> by A1, A2, TARSKI:def 2;
    per cases;
    suppose r = {};
::>       *60
      then r = <*> {0,1} by FINSEQ_1:def 6;
      hence r is FinSequence of {0,1};
      assume r^<*0*> in dom D;
      ::thus D.r = 0 by A1, FUNCOP_1:7;
    end;
    suppose
    A5: not r = {};
      set ZeroOne = {0,1};
      reconsider ZeroOne as non empty set;
      set Zero = 0;
      Zero in {0,1} by TARSKI:def 2;
      then reconsider Zero as Element of ZeroOne;
    A4: <*Zero*> is FinSequence of ZeroOne;
      r = <*0*> by A3, A5
       .= <*Zero*>;
      hence r is FinSequence of {0,1} by A4;
      assume r^<*0*> in dom D;
      thus D.r = 0 by A1, FUNCOP_1:7;
    end;
  end;
end;

registration
  cluster { {}, <*0*>, <*1*> } -> Tree-like;
  coherence
  proof
    set T = { {}, <*0*>, <*1*> };
    T = elementary_tree 2 by TREES_1:53;
    then reconsider T as Tree;
    T is Tree-like;
    hence { {}, <*0*>, <*1*> } is Tree-like;
  end;
end;

registration
  cluster { {}, <*0*>, <*1*> } --> 0 -> LambdaTerm-like;
  coherence
  proof
    set T = { {}, <*0*>, <*1*> };
  A6: T is finite;
    set D = T --> 0;
  A2: dom D = T by FUNCOP_1:13;
    hence dom D is finite by A6;
    reconsider T as Tree;
    let r be FinSequence of NAT;
    assume
  A1: r in dom D;
    then
  A3: r = {} or r = <*0*> or r = <*1*> by A1, A2, ENUMSET1:def 1;
    per cases;
    suppose r = {};
      then r = <*> {0,1} by FINSEQ_1:def 6;
      hence r is FinSequence of {0,1};
      assume r^<*0*> in dom D;
      thus D.r = 0 by A1, FUNCOP_1:7;
    end;
    suppose
    A5: r = <*0*>;
      set ZeroOne = {0,1};
      reconsider ZeroOne as non empty set;
      set Zero = 0;
      Zero in {0,1} by TARSKI:def 2;
      then reconsider Zero as Element of ZeroOne;
    A4: <*Zero*> is FinSequence of ZeroOne;
      r = <*0*> by A5
       .= <*Zero*>;
      hence r is FinSequence of {0,1} by A4;
      assume r^<*0*> in dom D;
      thus D.r = 0 by A1, FUNCOP_1:7;
    end;
    suppose not (r = {} or r = <*0*>);
      then
    A7: r = <*1*> by A3;
      set ZeroOne = {0,1};
      reconsider ZeroOne as non empty set;
      set One = 1;
      One in {0,1} by TARSKI:def 2;
      then reconsider One as Element of ZeroOne;
    A4: <*One*> is FinSequence of ZeroOne;
      r = <*1*> by A7
       .= <*One*>;
      hence r is FinSequence of {0,1};
      assume r^<*0*> in dom D;
      thus D.r = 0 by A1, FUNCOP_1:7;
    end;
  end;
end;

::: And then we can easily define a `LambdaTerm-like` cluster,
:::  and make a mode `LambdaTerm` out of it.
registration
  cluster LambdaTerm-like for DecoratedTree of NAT;
  existence
  proof
    set D = { {} } --> 0;
    take D;
    thus D is LambdaTerm-like;
  end;
end;

definition
  mode LambdaTerm is LambdaTerm-like DecoratedTree of NAT;
end;

definition
  func PreAbstractionTerm -> LambdaTerm equals
    { {}, <*0*> } --> 0;
  coherence
  proof
    set T = { {}, <*0*> };
    reconsider T as Tree;
    set D = T --> 0;
    reconsider D as DecoratedTree of NAT;
    D is LambdaTerm-like;
    then reconsider D as LambdaTerm;
    D is LambdaTerm;
    hence { {}, <*0*> } --> 0 is LambdaTerm;
  end;
end;

definition
  func PreApplicationTerm -> LambdaTerm equals
    { {}, <*0*>, <*1*> } --> 0;
  coherence
  proof
    set T = { {}, <*0*>, <*1*> };
    reconsider T as Tree;
    set D = T --> 0;
    reconsider D as DecoratedTree of NAT;
    D is LambdaTerm-like;
    then reconsider D as LambdaTerm;
    D is LambdaTerm;
    hence { {}, <*0*>, <*1*> } --> 0 is LambdaTerm;
  end;
end;

reserve M,N,P,Q for LambdaTerm;

::: #### Preservation under operations

::: `LambdaTerm`s are preserved under taking subterms, and composing
:::  terms. We'll register this knowledge in the type system.

::: Let Mizar know that `M|r` is also a `LambdaTerm`.
::: The definition of `|` that we are using is the definition
:::  that operates on (and returns) a `DecoratedTree`. Showing
:::  that retricting a `LambdaTerm` produces a `LambdaTerm-like`
:::  result ensures us that the result is a `LambdaTerm`.
registration
  let M be LambdaTerm,
      r be Element of dom M;

  cluster M|r -> LambdaTerm-like;
  coherence
  proof
    thus dom (M|r) is finite proof
      dom M is finite by Def1;
      then (dom M)|r is finite;
      hence thesis by TREES_2:def 10;
    end;

    let p be FinSequence of NAT;
    assume
  A3: p in dom (M|r);
    thus p is FinSequence of {0,1} proof
      dom (M|r) = (dom M)|r by TREES_2:def 10;
      then p in (dom M)|r by A3;
      then r^p in dom M by TREES_1:def 6;
      then r^p is FinSequence of {0,1} by Def1;
      hence thesis by FINSEQ_1:36;
    end;

    :: r^p^<*0*>
    set p0 = p^<*0*>;
    set rp = r^p;
    assume
  A4: p0 in dom (M|r);
    thus (M|r).p = 0 proof
      dom (M|r) is Tree-like;
      then
    A5: p0 in dom (M|r) by A4, TREES_1:21;
      then reconsider p0 as Element of dom (M|r);
      reconsider p0 as Element of (dom M)|r by TREES_2:def 10;
      p0 in (dom M)|r;
      then r^p0 in dom M by TREES_1:def 6;
      then
    A6: rp^<*0*> in dom M by FINSEQ_1:32;
      then rp in dom M by TREES_1:21;
      then M.rp = 0 by A6, Def1;
      then
    A8: M.(r^p) = 0;
      p in (dom M)|r by A3, TREES_2:def 10;
      then (M|r).p = M.(r^p) by TREES_2:def 10;
      hence (M|r).p = 0 by A8, TREES_2:def 10;
    end;
  end;
end;

::: Let Mizar know that `P with-replacement (p,Q)` is also a `LambdaTerm`.
::: First we prove a slightly more general theorem about the ranges of
:::  composed `DecoratedTree`s, and add this knowledge to the type system.
reserve X for set,
        D1,D2 for DecoratedTree,
        p for Element of dom D1;

theorem Th1:
  D1 is X-valued & D2 is Y-valued implies
    D1 with-replacement (p,D2) is (X \/ Y)-valued
proof
  assume
A4: D1 is X-valued;
  assume
A5: D2 is Y-valued;
  set D = D1 with-replacement (p,D2);
  set T = dom D;
  rng D c= X \/ Y
  proof
    let x be set;
    assume x in rng D;
    then ex q being set st [q,x] in D by RELAT_1:def 5;
    then consider q being set such that
  A1: [q,x] in D;
  A2: q in T by A1, RELAT_1:def 4;
    T is Tree by TREES_2:def 8;
    then reconsider q as FinSequence of NAT by A2, TREES_1:19;
  A13: T = dom D1 with-replacement (p, dom D2) by TREES_2:def 11;
    then
  A3: ((not p is_a_prefix_of q & D.q = D1.q) or
      (ex r st r in dom D2 & q = p^r & D.q = D2.r)) by A2, TREES_2:def 11;
    per cases;
    suppose
    A6: (not p is_a_prefix_of q & D.q = D1.q);
      [q,x] in D by A1;
      then D.q = x by A2, FUNCT_1:def 2;
      then
    A7: D1.q = x by A6;
    A12: q in dom D1
      proof
      A14: (q in dom D1 & not p is_a_proper_prefix_of q or
          ex r st r in dom D2 & q = p^r) by A2, A13, TREES_1:def 9;
        per cases;
        suppose q in dom D1 & not p is_a_proper_prefix_of q;
          hence q in dom D1;
        end;
        suppose not (q in dom D1 & not p is_a_proper_prefix_of q);
          then ex r st r in dom D2 & q = p^r by A14;
          then
        A15: p is_a_prefix_of q by TREES_1:1;
          assume not q in dom D1;
          thus contradiction by A6, A15;
        end;
      end;
      [q,x] in D1 by A7, A12, FUNCT_1:def 2;
      then
    A8: x in rng D1 by RELAT_1:def 5;
      rng D1 c= X by A4, RELAT_1:def 19;
      then x in X by A8;
      hence x in (X \/ Y) by XBOOLE_0:def 3;
    end;
    suppose not (not p is_a_prefix_of q & D.q = D1.q);
      then (ex r st r in dom D2 & q = p^r & D.q = D2.r) by A3;
      then consider r such that
    A9: r in dom D2 & q = p^r & D.q = D2.r;
      [q,x] in D by A1;
      then D.q = x by A2, FUNCT_1:def 2;
      then D2.r = x by A9;
      then [r,x] in D2 by A9, FUNCT_1:def 2;
      then
    A11: x in rng D2 by RELAT_1:def 5;
      rng D2 c= Y by A5, RELAT_1:def 19;
      then x in Y by A11;
      hence x in (X \/ Y) by XBOOLE_0:def 3;
    end;
  end;
  hence thesis by RELAT_1:def 19;
end;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> NAT-valued;
  coherence
  proof
  A1: P is NAT-valued by Def1;
  A2: Q is NAT-valued by Def1;
    P with-replacement (p,Q) is (NAT \/ NAT)-valued by A1, A2, Th1;
    hence P with-replacement (p,Q) is NAT-valued by XBOOLE_0:def 3;
  end;
end;

reserve R for DecoratedTree,
        p for Element of dom P;

theorem Th2:
  P with-replacement (p,Q) is LambdaTerm-like
proof
  set R = P with-replacement (p,Q);
  thus dom R is finite
  proof
  A1: dom P is finite by Def1;
  A2: dom Q is finite by Def1;
    dom R = (dom P) with-replacement (p,dom Q) by TREES_2:def 11;
    hence thesis by A1, A2;
  end;

  let r;
  assume
A3: r in dom R;
  thus r is FinSequence of {0,1}
  proof
    dom R = (dom P) with-replacement (p,dom Q) by TREES_2:def 11;
    then
  A4: ((r in dom P & not p is_a_proper_prefix_of r) or
      (ex q st q in dom Q & r = p^q)) by A3, TREES_1:def 9;
    per cases;
    suppose (r in dom P & not p is_a_proper_prefix_of r);
      hence r is FinSequence of {0,1} by Def1;
    end;
    suppose not (r in dom P & not p is_a_proper_prefix_of r);
      then (ex q st q in dom Q & r = p^q) by A4;
      then consider q such that
    A5: q in dom Q & r = p^q;
      q is FinSequence of {0,1} by A5, Def1;
      then reconsider q as FinSequence of {0,1};
      p is FinSequence of {0,1} by Def1;
      then reconsider p as FinSequence of {0,1};
      p^q is FinSequence of {0,1};
      hence thesis by A5;
    end;
  end;
  set r0 = r^<*0*>;
  assume
A6: r0 in dom R;
  then r0 in (dom P) with-replacement (p,dom Q) by TREES_2:def 11;
  then
A7: ((r0 in (dom P) & not p is_a_proper_prefix_of r0) or
     (ex q st q in (dom Q) & r0 = p^q)) by TREES_1:def 9;
  per cases;
  suppose
  A13: (r0 in (dom P) & not p is_a_proper_prefix_of r0);
    then
  A8: r0 in dom P;
    then
  A12: r in dom P by TREES_1:21;
    then
  A9: P.r = 0 by A8, Def1;
  A10: not p is_a_prefix_of r
    proof
      assume p is_a_prefix_of r;
      then p is_a_proper_prefix_of r0 by TREES_1:8;
      hence contradiction by A13;
    end;
    R.r = P.r by A10, A12, TREES_3:45;
    hence R.r = 0 by A9;
  end;
  suppose not (r0 in (dom P) & not p is_a_proper_prefix_of r0);
    then (ex q st q in (dom Q) & r0 = p^q) by A7;
    then consider q such that
  A14: q in (dom Q) & r0 = p^q;
    per cases;
    suppose ex q2 being FinSequence, n being set st q = q2^<*n*>;
      then consider q2 being FinSequence, n being set such that
    A15: q = q2^<*n*>;
      q2 is FinSequence of NAT by A15, FINSEQ_1:36;
      then reconsider q2 as FinSequence of NAT;
      r^<*0*> = r0
        .= p^q by A14
        .= p^(q2^<*n*>) by A15
        .= (p^q2)^<*n*> by FINSEQ_1:32;
      then
    A19: r = (p^q2) & <*0*> = <*n*> by FINSEQ_2:17;
      then
    A16: 0 = n by FINSEQ_1:76;
      q in dom Q by A14;
      then
    A17: q2^<*0*> in dom Q by A14, A15, A16;
      then
    A18: q2 in dom Q by TREES_1:21;
      then Q.q2 = 0 by Def1, A17;
      then R.(p^q2) = 0 by A18, TREES_3:46;
      hence R.r = 0 by A19;
    end;
    suppose
    A20: not ex q2 being FinSequence, n being set st q = q2^<*n*>;
    A21: q = {}
      proof
        assume q <> {};
        then ex q2 being FinSequence,
          n being set st q = q2^<*n*> by FINSEQ_1:46;
        hence contradiction by A20;
      end;
    A30: r0 = p by A14, A21, FINSEQ_1:34;
      then
    A22: r0 in dom P;
      then
    A23: r in dom P by A22, TREES_1:21;
      then
    A24: P.r = 0 by A22, Def1;
    A27: not p is_a_prefix_of r
      proof
        assume p is_a_prefix_of r;
        then
      A28: p c= r;
        r0 = p by A30;
        then r0 c= p by XBOOLE_0:def 10;
        then r0 is_a_prefix_of p;
        then r is_a_proper_prefix_of p by TREES_1:7;
        then
      A32: r c< p;
        then r c= p by XBOOLE_0:def 8;
        then
      A31: r = p by A28, XBOOLE_0:def 10;
        r <> p by A32, XBOOLE_0:def 8;
        hence contradiction by A31;
      end;
      R.r = P.r by A23, A27, TREES_3:45;
      hence R.r = 0 by A24;
    end;
  end;
end;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> LambdaTerm-like;
  coherence
  proof
    thus thesis by Th2;
  end;
end;

definition
  let P be LambdaTerm,
      p be Element of dom P,
      Q be LambdaTerm;

  redefine func P with-replacement (p,Q) -> LambdaTerm;
  coherence;
end;

::: ### Helper definitions
::: Some helper definitions for working with lambda terms.

::: #### Variable occurences
definition
  let M be LambdaTerm,
      r; :: be Node of M;
  
  pred r is_variable_in M means
    :Def5:
    r in dom M &
    not r^<*0*> in dom M;

  pred r is_abstraction_in M means
    :Def6:
    r in dom M &
    r^<*0*> in dom M & not r^<*1*> in dom M;

  pred r is_application_in M means
    :Def7:
    r in dom M &
    r^<*0*> in dom M & r^<*1*> in dom M;
end;

definition
  let M be LambdaTerm,
      r be Node of M;

  func abstr-depth (r,M) -> Element of NAT equals
    card { p where p is Node of M
           : p is_a_proper_prefix_of r &
             p is_abstraction_in M };
  coherence
  proof
    set abstractions = { p where p is Node of M
                         : p is_a_proper_prefix_of r &
                           p is_abstraction_in M };
  end;
::> *70
end;

::: By $r$ being an _active variable_ of some term $M$ (or more precisely,
:::  a path identifying an active variable), I mean that if $\lambda M$ were
:::  to be applied to some other term $N$, we would substitute this variable
:::  by $M$.
definition
  let M be LambdaTerm,
      r be Node of M;
  
  pred r is_active_variable_in M means
    r is_variable_in M &
    M.r = abstr-depth (r,M);
end;

::: #### Abstraction and application

::: Then we can define abstraction and application
definition
  let M;
  
  func Abs(M) -> LambdaTerm means
    it|<*0*> = M & not <*1*> in dom it;
  existence
  proof
    set e = <*0*>;
    dom PreAbstractionTerm = { {}, <*0*> } by FUNCOP_1:13;
    then <*0*> in dom PreAbstractionTerm by TARSKI:def 2;
    then reconsider e as Element of dom PreAbstractionTerm;
    set D = PreAbstractionTerm with-replacement (e, M);

    take D;
    thus D|<*0*> = M;
::>                *4
    thus not <*1*> in dom D;
::>                       *4
  end;
  uniqueness;
::>        *4
end;

definition
  let M,N;

  func App(M,N) -> LambdaTerm means
    it|<*0*> = M & it|<*1*> = N;
  existence
  proof
    set e0 = <*0*>;
    dom PreApplicationTerm = { {}, <*0*>, <*1*> } by FUNCOP_1:13;
    then <*0*> in dom PreApplicationTerm by ENUMSET1:def 1;
    then reconsider e0 as Element of dom PreApplicationTerm;
    set preD = PreApplicationTerm with-replacement (e0, M);
    preD is LambdaTerm;

    set e1 = <*1*>;
  A1: dom preD = (dom PreApplicationTerm) with-replacement (e0, dom M)
      by TREES_2:def 11;
    dom PreApplicationTerm = { {}, <*0*>, <*1*> } by FUNCOP_1:13;
    then
  A2: <*1*> in dom PreApplicationTerm by ENUMSET1:def 1;
    not e0 is_a_proper_prefix_of e1;
::>                               *4
    then <*1*> in dom preD by A1, A2, TREES_1:def 9;
    then reconsider e1 as Element of dom preD;
    set D = preD with-replacement (e1, N);
    D is LambdaTerm;
    
    take D;
    thus D|<*0*> = M;
::>                *4
    thus D|<*1*> = N;
::>                *4
  end;
  uniqueness;
::>        *4
end;

definition
  let M,N;

  :: TODO better definition with decorated tree replacements

  func SubstituteActiveVar(M,N) -> LambdaTerm means
    :: most things are the same,
    (for r st not (ex p being Element of dom N
                      st p is_active_variable_in N & p is_a_prefix_of r)
           holds [r,x] in it iff [r,x] in N
    ) &
    :: except that the active variables are replaced with M
    (for r being Element of dom N
            st r is_active_variable_in N
            holds it|r = M);
  existence;
::>       *4
  uniqueness;
::>        *4
end;

::: ### Lifting

definition
  let P,n,k;
  let p be Node of P;

  :: When lifting P with n and k, then x should be put to p.
  func LiftVal(P,n,k,p) -> Nat means
    :Def4:
    (p is_variable_in P & P.p >= k & it = P.p + n) or
    (p is_variable_in P & P.p < k  & it = P.p) or
    (not p is_variable_in P & it = 0);

  existence
  proof
    p is_variable_in P or not p is_variable_in P;
    per cases;
    suppose
    A1: p is_variable_in P;
      P.p >= k or not P.p >= k;
      per cases;
      suppose
      A2: P.p >= k;
        take P.p + n;
        thus thesis by A1,A2;
      end;
      suppose
      A3: not P.p >= k;
        then P.p < k;
        take P.p;
        thus thesis by A1,A3;
      end;
    end;
    suppose
    A4: not p is_variable_in P;
      take 0;
      thus thesis by A4;
    end;
  end;
  uniqueness;
end;

reserve p2,r2 for Node of P;

definition
  let P,n,k;
  let p be set;

  :: When lifting P with n and k, then x should be put to p.
  func LiftVal2(P,n,k,p) -> Nat means
    :Def2:
    (ex p2 st p = p2 & it = LiftVal(P,n,k,p2)) or
    ((not ex p2 st p = p2) & it = 0);
    
  existence
  proof
    (ex p2 st p = p2) or (not ex p2 st p = p2);
    per cases;
    suppose ex p2 st p = p2;
      then consider p2 such that
    A2: p = p2;
      take LiftVal(P,n,k,p2);
      thus thesis by A2;
    end;
    suppose
    A1: not ex p2 st p = p2;
      take 0;
      thus thesis by A1;
    end;
  end;
  uniqueness
  proof
    let i,j be Nat;
    assume
  A10: (ex p2 st p = p2 & i = LiftVal(P,n,k,p2)) or
      ((not ex p2 st p = p2) & i = 0);
    assume
  A11: (ex p2 st p = p2 & j = LiftVal(P,n,k,p2)) or
      ((not ex p2 st p = p2) & j = 0);
    (ex p2 st p = p2) or (not ex p2 st p = p2);
    per cases;
    suppose
    A13: ex p2 st p = p2;
      then consider p2 such that
    A12: p = p2;
    A16: i = LiftVal(P,n,k,p2)
      proof
        assume
      A14: not thesis;
        ex p2 st p = p2 by A13;
        then not ((not ex p2 st p = p2) & i = 0);
        hence contradiction by A10,A12,A14;
      end;
    A17: j = LiftVal(P,n,k,p2)
      proof
        assume
      A15: not thesis;
        ex p2 st p = p2 by A13;
        then not ((not ex p2 st p = p2) & j = 0);
        hence contradiction by A11,A12,A15;
      end;
      thus i = j by A16,A17;
    end;
    suppose
    A18: not ex p2 st p = p2;
    A19: i = 0 by A10,A18;
    A20: j = 0 by A11,A18;
      thus i = j by A19,A20;
    end;
  end;
end;

definition
  let P,n,k;

  func Lift(P,n,k) -> LambdaTerm means
    :Def3:
    :: The resulting term is of the exact same size/shape,
    dom it = dom P &
    :: except that variables are lifted by $n$ iff they are greater/equal to $k$.
    (for p st p in dom P holds [p,LiftVal(P,n,k,p)] in it);

  :: Proof by TREES_2:sch 7
  existence
  proof
    deffunc f(set) = LiftVal2(P,n,k,$1);
    :: T() = dom P
    :: f(set) -> set = LiftVal2(P,n,k,$1)
    ex D st dom D = dom P &
      for p being FinSequence of NAT st p in dom P holds D.p = f(p)
      from TREES_2:sch 7;
    then consider D such that
  A1: dom D = dom P and
  A2: for p being FinSequence of NAT st p in dom P holds D.p = f(p);
  A3: D is NAT-valued
    proof
      rng D c= NAT
      proof
        let x;
        assume x in rng D;
        then ex p being set st [p,x] in D by RELAT_1:def 5;
        then consider p being set such that
      A14: [p,x] in D;
      A18: p in dom D by A14, RELAT_1:def 4;
        then
      A15: p in dom P by A1;
        set p3 = p;
        reconsider p3 as FinSequence of NAT by A15,TREES_2:def 8, TREES_1:19;
        ::reconsider p as Node of P by A15;
      A17: D.p = x by FUNCT_1:1, A14, A18;
      A16: x = LiftVal2(P,n,k,p3) by A2,A15,A17;
        then
      A20: (ex p2 st p = p2 & x = LiftVal(P,n,k,p2)) or
          ((not ex p2 st p = p2) & x = 0) by Def2,A17;
        per cases;
        suppose ex p2 st p = p2 & x = LiftVal(P,n,k,p2);
          then consider p2 such that
        A21: p = p2 & x = LiftVal(P,n,k,p2);
        A19: (p2 is_variable_in P & P.p2 >= k & x = P.p2 + n) or
            (p2 is_variable_in P & P.p2 < k  & x = P.p2) or
            (not p2 is_variable_in P & x = 0) by Def4,A21;
          per cases;
          suppose p2 is_variable_in P & P.p2 >= k & x = P.p2 + n;
            hence x in NAT;
          end;
          suppose p2 is_variable_in P & P.p2 < k  & x = P.p2;
            hence x in NAT;
          end;
          suppose not (p2 is_variable_in P & P.p2 >= k & x = P.p2 + n)
                & not (p2 is_variable_in P & P.p2 < k  & x = P.p2);
            then not p2 is_variable_in P & x = 0 by A19;
            hence x in NAT;
          end;
        end;
        suppose not (ex p2 st p = p2 & x = LiftVal(P,n,k,p2));
          then (not ex p2 st p = p2) & x = 0 by A20;
          hence x in NAT;
        end;
      end;
      hence thesis by RELAT_1:def 19;
    end;
  A4: D is LambdaTerm-like
    proof
      dom P is finite by Def1;
      hence dom D is finite by A1;
      let r;
      assume r in dom D;
      then
    A9: r in dom P by A1;
      hence r is FinSequence of {0,1} by Def1;
      assume r^<*0*> in dom D;
      then
    A12: r^<*0*> in dom P by A1;
      then P.r = 0 by A9,Def1;
      set r2 = r;
      reconsider r2 as Node of P by A9;
    A10: LiftVal2(P,n,k,r) = LiftVal(P,n,k,r2)
      proof
        assume not thesis;
        then not (ex r2 st r = r2 & LiftVal2(P,n,k,r) = LiftVal(P,n,k,r2));
        then
      A11: (not ex r2 st r = r2) & LiftVal2(P,n,k,r) = 0 by Def2;
        r is Node of P by A9;
        then ex r2 st r = r2;
        hence contradiction by A11;
      end;
    A13: not r2 is_variable_in P
      proof
        assume r2 is_variable_in P;
        then not r^<*0*> in dom P by Def5;
        hence contradiction by A12;
      end;
      LiftVal(P,n,k,r2) = 0 by A13, Def4;
      then LiftVal2(P,n,k,r) = 0 by A10;
      hence D.r = 0 by A2,A9;
    end;
    reconsider D as LambdaTerm by A3,A4;
    take D;
    thus dom D = dom P by A1;
    let p;
    assume
  A6: p in dom P;
    then p in dom D by A1;
    then [p,D.p] in D by FUNCT_1:1;
    then
  A5: [p,LiftVal2(P,n,k,p)] in D by A2;
  A7: LiftVal2(P,n,k,p) = LiftVal(P,n,k,p)
    proof
      assume not thesis;
      then not (ex p2 st p = p2 & LiftVal2(P,n,k,p) = LiftVal(P,n,k,p2));
      then
    A8: (not ex p2 st p = p2) & LiftVal2(P,n,k,p) = 0 by Def2;
      p is Node of P by A6;
      then ex p2 st p = p2;
      hence contradiction by A8;
    end;
    hence [p,LiftVal(P,n,k,p)] in D by A5,A7;
  end;
  uniqueness
  proof
    let Q1,Q2 be LambdaTerm;
    assume
  A1: dom Q1 = dom P &
      (for p st p in dom P holds [p,LiftVal(P,n,k,p)] in Q1);
    assume
  A2: dom Q2 = dom P &
      (for p st p in dom P holds [p,LiftVal(P,n,k,p)] in Q2);
  A4: for p being set st p in dom Q1 holds Q1.p = Q2.p
    proof
      let p be set;
      assume p in dom Q1;
      then
    A5: p in dom P by A1;
      set p2 = p;
      reconsider p2 as FinSequence of NAT by A5,TREES_2:def 8, TREES_1:19;
      reconsider p2 as Node of P by A5;
      [p2,LiftVal(P,n,k,p2)] in Q1 by A1,A5;
      then
    A6: Q1.p2 = LiftVal(P,n,k,p2) by FUNCT_1:1,A5;
      [p2,LiftVal(P,n,k,p2)] in Q2 by A2,A5;
      then
    A7: Q2.p2 = LiftVal(P,n,k,p2) by FUNCT_1:1,A5;
      thus Q1.p = Q2.p by A6,A7;
    end;
    thus Q1 = Q2 by A1,A2,A4,FUNCT_1:2;
  end;
end;

::: ### Reduction and conversion

::: First I define _shallow_ one-step beta substitution, which only
:::  states (the De Bruijn equivalent of)
:::  $(\\lambda x.N)M \\to_{\\beta} N[x:=M]$.

definition
  let P,Q;
  
  :: P === (\x.N)M --> N[x:=M] === Q
  pred P beta_shallow Q means
    ex M,N st
      :: P === (\x.N)M
      P = App(Abs(N),M) &

      :: Q === N[x:=M]
      Q = SubstituteActiveVar(N,M);
end;

::: Then we extend this ordinary one-step beta reduction, that is,
:::  any subterm is also allowed to reduce.

::: Note that I had to use a work-around here, where I have two
:::  set-theoretically identical elements `p` and `q`, but considered
:::  in Mizar as having different types to enable the two `|` operations
:::  to work. I also tried defining something like `Element of (dom M),(dom N)`,
:::  but this is extremely difficult, if not impossible.
definition
  let M,N;

  pred M beta N means
    ex
      p being Element of dom M,
      q being Element of dom N st
        p = q &
        M|p beta_shallow N|q &
        for q st not p is_a_prefix_of q holds
          [r,x] in M iff [r,x] in N;
end;

::: We close the relation under transitivity and reflexivity
:::  to get the full beta reduction relation.
definition
  let M,N;
  
  pred M beta* N means
    M = N or
    ex P st M beta P & P beta N;
end;

::: And then close under symmetry to get beta conversion.
definition
  let M,N;
  
  pred M beta= N means
    M beta* N or N beta* M;
end;


::>
::> 4: This inference is not accepted
::> 60: Something remains to be proved in this case
::> 70: Something remains to be proved
