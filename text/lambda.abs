::: # Lambda calculus

::: Original files:
:::  [.abs](text/lambda.abs),
:::  [.miz](text/lambda.miz),
:::  [.voc](dict/lambda.voc)

::: @TOC

::: TODO note how we almost never work by inductive/recursive means,
:::  in constract with, say, Coq.

:: Environ originally taken from `finseq_2`. Later, I added trees and orders.
environ

  :: Vocabularies are basically for Mizar's lexer.
  vocabularies LAMBDA,
    FINSET_1,
    NUMBERS,
    NAT_1, XBOOLE_0, SUBSET_1, FINSEQ_1, XXREAL_0, CARD_1,
    ARYTM_1, ARYTM_3, TARSKI, ORDINAL4, FUNCOP_1,
    RELAT_2, RELAT_1,
    FUNCT_1, FUNCT_2,
    ZFMISC_1, PARTFUN1,
    ORDERS_2, ORDERS_1,
    FINSEQ_2, PBOOLE, CARD_3, VALUED_1,
    TREES_4, TREES_3, TREES_2, TREES_1;

  :: Radix type specifications
  :: But it also helped [175 unknown attribute format] error with [finite set]
  notations FINSET_1,
    TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1,
    NUMBERS, XCMPLX_0, DOMAIN_1, NAT_1, RELAT_1, PARTFUN1,
    RELAT_2, RELSET_1,
    FUNCT_1, FUNCT_2,
    FUNCT_3, FINSEQ_1, FINSEQ_2, BINOP_1, PBOOLE, FUNCOP_1, CARD_3,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ORDERS_1, ORDERS_2,
    XXREAL_0, VALUED_1,
    RECDEF_1;

  :: For modes? (unknown mode format resolved)
  constructors RELAT_2, RELAT_1,
    PARTFUN1, BINOP_1, DOMAIN_1,
    FUNCT_1, FUNCT_2, FUNCT_3,
    FUNCOP_1,
    RELSET_1,
    SQUARE_1, NAT_1, FINSEQ_1, FINSEQ_2, PBOOLE, CARD_3, VALUED_1, SETFAM_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ORDERS_1, ORDERS_2,
    RECDEF_1,
    FINSET_1,
    ENUMSET1,
    WELLORD2;

  :: Definition are for automatically unfolding predicates
  ::  in the thesis you are proving
  definitions TARSKI,
    FUNCT_1, FUNCT_2,
    FINSEQ_1, CARD_1, PBOOLE, FUNCOP_1,
    ORDERS_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    ::XTUPLE_0;
    MCART_1; ::, FUNCT_5, RECDEF_1;

  :: Registrations are for clusters (showing that a type exists (is non-empty),
  ::  and automatically adding adjectives)
  registrations XBOOLE_0, SUBSET_1, ORDINAL1, PARTFUN1,
    ::RELAT_2,
    RELAT_1,
    FUNCT_1, FUNCT_2,
    FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, FINSEQ_2, CARD_1, RELSET_1,
    PBOOLE, CARD_3,
    ORDERS_2,
    TREES_4, TREES_3, TREES_2, TREES_1,
    FINSET_1;

  :: Load theorem en definition labels
  theorems FUNCOP_1, RELAT_1, TARSKI, FINSEQ_1, FINSEQ_2,
    ::XTUPLE_0,
    MCART_1, FUNCT_5, :: RECDEF_1,
    FUNCT_1,
    TREES_4, TREES_3, TREES_2, TREES_1,
    XBOOLE_0, SUBSET_1, RELAT_2, ENUMSET1,
    CARD_1, CARD_2, CARD_3, CARD_4;

  schemes RECDEF_1, TREES_2;

  requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

begin

::: ## Syntax and behaviour

reserve T,T1,T2 for Tree,
        D for DecoratedTree,
        p,q,q2,r for FinSequence of NAT,
        x,y,X,Y for set,
        i,j,k,l,m,n for Element of NAT;

::: ### Lambda terms

::: A _lambda term_ is identified with it's AST (abstract
:::  syntax tree). More precisely, we identify a lambda term
:::  with a finite decorated tree.
::: The nodes of the tree denote either application, abstraction
:::  or a variable. Using _De Bruijn_ variable indexing, we decorate
:::  variables with their De Bruijn index (a natural nuber). Note
:::  that we needn't explicitly annotate the type of a node,
:::  as the three types of nodes differ in how many children they must
:::  have: an application always has two children, an abstraction but one,
:::  and variables don't have any. So it suffices to decorate application
:::  and abstraction nodes with some default value (say, $0$).

::: In Mizar, a `Tree` is a non-empty subset of `NAT*`, so a set of finite
:::  sequences of natural numbers, such that certain logical properties hold.
::: Every such sequence denotes a node in the tree, and can be interpreted
:::  as a _path specification_ (how to get there, from the top). We see, then,
:::  that lambda term trees are a specific subset of general trees, in which
:::  only finite sequences of $\\{0,1\\}$ are used to denote nodes, nodes
:::  with children are decorated with a $0$, and is also finite in height.
::: By _decorating_ a node `r` with a number `n`, we mean that `M.r = n`.
::: Here `M` is the `DecoratedTree of NAT` which represents the lambda term.

definition
  let D;

  attr D is LambdaTerm-like means
:: LAMBDA:def 1

    dom D is finite &
    for r st r in dom D holds
      r is FinSequence of {0,1} &
      (r^<*0*> in dom D implies D.r = 0);
end;

::: Some simple `LambdaTerm-like` things.

::: TODO: some more of these simple trees, for easy usage
:::  later on, when defining application and abstraction.

registration
  cluster { {} } --> 0 -> LambdaTerm-like;
end;

registration
  cluster { <*> NAT } -> Tree-like;
end;

registration
  cluster { <*> NAT } --> 0 -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*> } -> Tree-like;
end;

registration
  cluster { {}, <*0*> } --> 0 -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } -> Tree-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } --> 0 -> LambdaTerm-like;
end;

::: And then we can easily define a `LambdaTerm-like` cluster,
:::  and make a mode `LambdaTerm` out of it.
registration
  cluster LambdaTerm-like for DecoratedTree of NAT;
end;

definition
  mode LambdaTerm is LambdaTerm-like DecoratedTree of NAT;
end;

definition
  func PreAbstractionTerm -> LambdaTerm equals
:: LAMBDA:def 2
    { {}, <*0*> } --> 0;
end;

definition
  func PreApplicationTerm -> LambdaTerm equals
:: LAMBDA:def 3
    { {}, <*0*>, <*1*> } --> 0;
end;

reserve M,N,P,Q for LambdaTerm;

::: #### Preservation under operations

::: `LambdaTerm`s are preserved under taking subterms, and composing
:::  terms. We'll register this knowledge in the type system.

::: Let Mizar know that `M|r` is also a `LambdaTerm`.
::: The definition of `|` that we are using is the definition
:::  that operates on (and returns) a `DecoratedTree`. Showing
:::  that retricting a `LambdaTerm` produces a `LambdaTerm-like`
:::  result ensures us that the result is a `LambdaTerm`.
registration
  let M be LambdaTerm,
      r be Element of dom M;

  cluster M|r -> LambdaTerm-like;
end;

::: Let Mizar know that `P with-replacement (p,Q)` is also a `LambdaTerm`.
::: First we prove a slightly more general theorem about the ranges of
:::  composed `DecoratedTree`s, and add this knowledge to the type system.
reserve X for set,
        D1,D2 for DecoratedTree,
        p for Element of dom D1;

theorem :: LAMBDA:1
  D1 is X-valued & D2 is Y-valued implies
    D1 with-replacement (p,D2) is (X \/ Y)-valued;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> NAT-valued;
end;

reserve R for DecoratedTree,
        p for Element of dom P;

theorem :: LAMBDA:2
  P with-replacement (p,Q) is LambdaTerm-like;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> LambdaTerm-like;
end;

definition
  let P be LambdaTerm,
      p be Element of dom P,
      Q be LambdaTerm;

  redefine func P with-replacement (p,Q) -> LambdaTerm;
end;

::: ### Helper definitions
::: Some helper definitions for working with lambda terms.

::: #### Variable occurences
definition
  let M be LambdaTerm,
      r; :: be Node of M;

  pred r is_variable_in M means
:: LAMBDA:def 4

    r in dom M &
    not r^<*0*> in dom M;

  pred r is_abstraction_in M means
:: LAMBDA:def 5

    r in dom M &
    r^<*0*> in dom M & not r^<*1*> in dom M;

  pred r is_application_in M means
:: LAMBDA:def 6

    r in dom M &
    r^<*0*> in dom M & r^<*1*> in dom M;
end;

definition
  let M be LambdaTerm,
      r be Node of M;

  func abstr-depth (r,M) -> Element of NAT equals
:: LAMBDA:def 7
    card { p where p is Node of M
           : p is_a_proper_prefix_of r &
             p is_abstraction_in M };
::> *70
end;

::: By $r$ being an _active variable_ of some term $M$ (or more precisely,
:::  a path identifying an active variable), I mean that if $\lambda M$ were
:::  to be applied to some other term $N$, we would substitute this variable
:::  by $M$.
definition
  let M be LambdaTerm,
      r be Node of M;

  pred r is_active_variable_in M means
:: LAMBDA:def 8
    r is_variable_in M &
    M.r = abstr-depth (r,M);
end;

::: #### Abstraction and application

::: Then we can define abstraction and application
definition
  let M;

  func Abs(M) -> LambdaTerm means
:: LAMBDA:def 9
    it|<*0*> = M & not <*1*> in dom it;
::>        *4
end;

definition
  let M,N;

  func App(M,N) -> LambdaTerm means
:: LAMBDA:def 10
    it|<*0*> = M & it|<*1*> = N;
::>        *4
end;

definition
  let M,N;

  :: TODO better definition with decorated tree replacements

  func SubstituteActiveVar(M,N) -> LambdaTerm means
:: LAMBDA:def 11
    :: most things are the same,
    (for r st not (ex p being Element of dom N
                      st p is_active_variable_in N & p is_a_prefix_of r)
           holds [r,x] in it iff [r,x] in N
    ) &
    :: except that the active variables are replaced with M
    (for r being Element of dom N
            st r is_active_variable_in N
            holds it|r = M);
::>        *4
end;

::: ### Lifting

definition
  let P,n,k;
  let p be Node of P;

  :: When lifting P with n and k, then x should be put to p.
  func LiftVal(P,n,k,p) -> Nat means
:: LAMBDA:def 12

    (p is_variable_in P & P.p >= k & it = P.p + n) or
    (p is_variable_in P & P.p < k  & it = P.p) or
    (not p is_variable_in P & it = 0);
end;

reserve p2,r2 for Node of P;

definition
  let P,n,k;
  let p be set;

  :: When lifting P with n and k, then x should be put to p.
  func LiftVal2(P,n,k,p) -> Nat means
:: LAMBDA:def 13

    (ex p2 st p = p2 & it = LiftVal(P,n,k,p2)) or
    ((not ex p2 st p = p2) & it = 0);
end;

definition
  let P,n,k;

  func Lift(P,n,k) -> LambdaTerm means
:: LAMBDA:def 14

    :: The resulting term is of the exact same size/shape,
    dom it = dom P &
    :: except that variables are lifted by $n$ iff they are greater/equal to $k$.
    (for p st p in dom P holds [p,LiftVal(P,n,k,p)] in it);
end;

::: ### Reduction and conversion

::: First I define _shallow_ one-step beta substitution, which only
:::  states (the De Bruijn equivalent of)
:::  $(\\lambda x.N)M \\to_{\\beta} N[x:=M]$.

definition
  let P,Q;

  :: P === (\x.N)M --> N[x:=M] === Q
  pred P beta_shallow Q means
:: LAMBDA:def 15
    ex M,N st
      :: P === (\x.N)M
      P = App(Abs(N),M) &

      :: Q === N[x:=M]
      Q = SubstituteActiveVar(N,M);
end;

::: Then we extend this ordinary one-step beta reduction, that is,
:::  any subterm is also allowed to reduce.

::: Note that I had to use a work-around here, where I have two
:::  set-theoretically identical elements `p` and `q`, but considered
:::  in Mizar as having different types to enable the two `|` operations
:::  to work. I also tried defining something like `Element of (dom M),(dom N)`,
:::  but this is extremely difficult, if not impossible.
definition
  let M,N;

  pred M beta N means
:: LAMBDA:def 16
    ex
      p being Element of dom M,
      q being Element of dom N st
        p = q &
        M|p beta_shallow N|q &
        for q st not p is_a_prefix_of q holds
          [r,x] in M iff [r,x] in N;
end;

::: We close the relation under transitivity and reflexivity
:::  to get the full beta reduction relation.
definition
  let M,N;

  pred M beta* N means
:: LAMBDA:def 17
    M = N or
    ex P st M beta P & P beta N;
end;

::: And then close under symmetry to get beta conversion.
definition
  let M,N;

  pred M beta= N means
:: LAMBDA:def 18
    M beta* N or N beta* M;
end;


::>
::> 4: This inference is not accepted
::> 60: Something remains to be proved in this case
::> 70: Something remains to be proved
