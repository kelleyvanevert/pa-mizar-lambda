::: # Lambda calculus

::: Original files:
:::  [.abs](text/lambda.abs),
:::  [.miz](text/lambda.miz),
:::  [.voc](dict/lambda.voc)

::: @TOC

::: TODO note how we almost never work by inductive/recursive means,
:::  in constract with, say, Coq.

:: Environ originally taken from `finseq_2`. Later, I added trees and orders.
environ

  :: Vocabularies are basically for Mizar's lexer.
  vocabularies LAMBDA,
    FINSET_1,
    NUMBERS,
    NAT_1, XBOOLE_0, SUBSET_1, FINSEQ_1, XXREAL_0, CARD_1,
    ARYTM_1, ARYTM_3, TARSKI, ORDINAL4, FUNCOP_1,
    RELAT_2, RELAT_1,
    FUNCT_1, FUNCT_2,
    ZFMISC_1, PARTFUN1,
    ORDERS_2, ORDERS_1,
    FINSEQ_2, FINSEQ_4, PBOOLE, CARD_3, VALUED_1,
    TREES_1, TREES_2, TREES_3, TREES_4;

  :: Radix type specifications
  :: But it also helped [175 unknown attribute format] error with [finite set]
  notations FINSET_1,
    TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1,
    NUMBERS, XCMPLX_0, DOMAIN_1, NAT_1, RELAT_1, PARTFUN1,
    RELAT_2, RELSET_1,
    FUNCT_1, FUNCT_2,
    FUNCT_3, FINSEQ_1, FINSEQ_2, BINOP_1, PBOOLE, FUNCOP_1, CARD_3,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ORDERS_1, ORDERS_2,
    XXREAL_0, VALUED_1,
    RECDEF_1;

  :: For modes? (unknown mode format resolved)
  constructors RELAT_2, RELAT_1,
    PARTFUN1, BINOP_1, DOMAIN_1,
    FUNCT_1, FUNCT_2, FUNCT_3,
    FUNCOP_1,
    RELSET_1,
    SQUARE_1, NAT_1, FINSEQ_1, FINSEQ_2, PBOOLE, CARD_3, VALUED_1, SETFAM_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ORDERS_1, ORDERS_2,
    RECDEF_1,
    FINSET_1,
    ENUMSET1,
    WELLORD2;

  :: Definition are for automatically unfolding predicates
  ::  in the thesis you are proving
  definitions TARSKI,
    FUNCT_1, FUNCT_2,
    FINSEQ_1, CARD_1, PBOOLE, FUNCOP_1,
    ORDERS_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ::XTUPLE_0;
    MCART_1; ::, FUNCT_5, RECDEF_1;

  :: Registrations are for clusters (showing that a type exists (is non-empty),
  ::  and automatically adding adjectives)
  registrations XBOOLE_0, SUBSET_1, ORDINAL1, PARTFUN1,
    ::RELAT_2,
    RELAT_1,
    FUNCT_1, FUNCT_2,
    FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, FINSEQ_2, CARD_1, RELSET_1,
    PBOOLE, CARD_3,
    ORDERS_2,
    TREES_1, TREES_2, TREES_3, TREES_4,
    FINSET_1;

  :: Load theorem en definition labels
  theorems FUNCOP_1, RELAT_1, TARSKI, FINSEQ_1, FINSEQ_2,
    ::XTUPLE_0,
    MCART_1, FUNCT_5, :: RECDEF_1,
    FUNCT_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    XBOOLE_0, SUBSET_1, RELAT_2, ENUMSET1,
    CARD_1, CARD_2, CARD_3, CARD_4;

  schemes RECDEF_1, TREES_2, TREES_4;

  requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

begin

::: ## Syntax and behaviour

definition
  mode Variable is Element of NAT;
end;

reserve T,T1,T2 for Tree,
        D,D2,E for DecoratedTree,
        p,q,q0,q1,q2,r,r2 for FinSequence of NAT,
        x,y,z,X,Y,Z for set,
        i,j,k,l,m,n for Element of NAT,
        u,v,w for Variable;

::: ### Lambda terms

::: A _lambda term_ is identified with it's AST (abstract
:::  syntax tree). More precisely, we identify a lambda term
:::  with a finite decorated tree.
::: The nodes of the tree denote either application, abstraction
:::  or a variable. Using _De Bruijn_ variable indexing, we decorate
:::  variables with their De Bruijn index (a natural nuber). Note
:::  that we needn't explicitly annotate the type of a node,
:::  as the three types of nodes differ in how many children they must
:::  have: an application always has two children, an abstraction but one,
:::  and variables don't have any. So it suffices to decorate application
:::  and abstraction nodes with some default value (say, $0$).

::: In Mizar, a `Tree` is a non-empty subset of `NAT*`, so a set of finite
:::  sequences of natural numbers, such that certain logical properties hold.
::: Every such sequence denotes a node in the tree, and can be interpreted
:::  as a _path specification_ (how to get there, from the top). We see, then,
:::  that lambda term trees are a specific subset of general trees, in which
:::  only finite sequences of $\\{0,1\\}$ are used to denote nodes, nodes
:::  with children are decorated with a $0$, and is also finite in height.
::: By _decorating_ a node `r` with a number `n`, we mean that `M.r = n`.
::: Here `M` is the `DecoratedTree of NAT` which represents the lambda term.

definition
  let D;

  attr D is LambdaTerm-like means
:: LAMBDA:def 1

    dom D is finite &
    for r st r in dom D holds
      r is FinSequence of {0,1} &
      ((r^<*0*> in dom D & r^<*1*> in dom D)
          implies D.r = 0);
end;

::: Some simple `LambdaTerm-like` things.

::: TODO: some more of these simple trees, for easy usage
:::  later on, when defining application and abstraction.

registration
  let v;

  cluster { {} } --> v -> LambdaTerm-like;
end;

registration
  cluster { <*> NAT } -> Tree-like;
end;

registration
  let v;

  cluster { <*> NAT } --> v -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*> } -> Tree-like;
end;

registration
  let v;

  cluster { {}, <*0*> } --> v -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } -> Tree-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } --> 0 -> LambdaTerm-like;
end;

::: And then we can easily define a `LambdaTerm-like` cluster,
:::  and make a mode `LambdaTerm` out of it.
registration
  cluster LambdaTerm-like for DecoratedTree of NAT;
end;

definition
  mode LambdaTerm is LambdaTerm-like DecoratedTree of NAT;
end;

definition
  let v;

  func PreAbstractionTerm v -> LambdaTerm equals
:: LAMBDA:def 2
    { {}, <*0*> } --> v;
end;

definition
  func PreApplicationTerm -> LambdaTerm equals
:: LAMBDA:def 3
    { {}, <*0*>, <*1*> } --> 0;
end;

reserve M,N,P,Q for LambdaTerm;

definition
  let M,r;

  attr r is M-existingPath means
:: LAMBDA:def 4

    r is Element of dom M;
end;

::: #### Preservation under operations

::: `LambdaTerm`s are preserved under taking subterms, and composing
:::  terms. We'll register this knowledge in the type system.

::: Let Mizar know that `M|r` is also a `LambdaTerm`.
::: The definition of `|` that we are using is the definition
:::  that operates on (and returns) a `DecoratedTree`. Showing
:::  that retricting a `LambdaTerm` produces a `LambdaTerm-like`
:::  result ensures us that the result is a `LambdaTerm`.
registration
  let M be LambdaTerm,
      r be Element of dom M;

  cluster M|r -> LambdaTerm-like;
end;

::: Let Mizar know that `P with-replacement (p,Q)` is also a `LambdaTerm`.
::: First we prove a slightly more general theorem about the ranges of
:::  composed `DecoratedTree`s, and add this knowledge to the type system.
reserve X for set,
        D1,D2 for DecoratedTree,
        p for Element of dom D1;

theorem :: LAMBDA:1
  D1 is X-valued & D2 is Y-valued implies
    D1 with-replacement (p,D2) is (X \/ Y)-valued;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> NAT-valued;
end;

reserve p for Element of dom P;

theorem :: LAMBDA:2
  P with-replacement (p,Q) is LambdaTerm-like;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> LambdaTerm-like;
end;

definition
  let P be LambdaTerm,
      p be Element of dom P,
      Q be LambdaTerm;

  redefine func P with-replacement (p,Q) -> LambdaTerm;
end;

::: ### Helper definitions
::: Some helper definitions for working with lambda terms.

::: #### Variable occurences
definition
  let M be LambdaTerm,
      r; :: be Node of M;

  pred r is_variable_in M means
:: LAMBDA:def 5

    r in dom M &
    not r^<*0*> in dom M;

  pred r is_abstraction_in M means
:: LAMBDA:def 6

    r in dom M &
    r^<*0*> in dom M & not r^<*1*> in dom M;

  pred r is_application_in M means
:: LAMBDA:def 7

    r in dom M &
    r^<*0*> in dom M & r^<*1*> in dom M;
end;

definition
  let M,r,v;

  pred M,r holds_variable v means
:: LAMBDA:def 8

    r is_variable_in M &
    M.r = n;

  pred M,r abstracts v means
:: LAMBDA:def 9

    r is_abstraction_in M &
    M.r = n;
end;

definition
  let M,v;

  pred M contains_variable v means
:: LAMBDA:def 10

    ex r st M,r holds_variable v;
end;

::: #### Abstraction and application

reserve p for FinSequence of NAT;

theorem :: LAMBDA:3
    not q,r are_c=-comparable
  implies
    not q is_a_prefix_of r
  & not r is_a_prefix_of q
  & not q is_a_proper_prefix_of r
  & not r is_a_proper_prefix_of q;

::: Why the hell would TARSKI:def 3 not include transitivity?!
theorem :: LAMBDA:4
  X c= Y & Y c= Z implies X c= Z;

theorem :: LAMBDA:5
    not p,q are_c=-comparable
  implies
    not p,q^r are_c=-comparable;

::: The `DecoratedTree` analog of `TREES_1:33`
theorem :: LAMBDA:6
    r in dom D
  implies
    D2 = D with-replacement (r,D2)|r;

reserve q,r for Element of T;

theorem :: LAMBDA:7
    not q,r are_c=-comparable
  implies
    T|r = (T with-replacement (q,T2))|r;

reserve q,r for Element of dom D;

theorem :: LAMBDA:8
    not q,r are_c=-comparable
  implies
    D|r = (D with-replacement (q,D2))|r;

reserve q,r for FinSequence of NAT;

definition
  let v;

  func Var(v) -> LambdaTerm equals
:: LAMBDA:def 11

    { <*> NAT } --> v;
end;

::: Then we can define abstraction and application
::definition
::  func AbsLoc -> FinSequence of NAT equals <*0*>;
::  coherence;
::end;
::
::definition
::  let v,r;
::
::  attr r is v-existingVarPath means
::    :Def19:
::    r is (PreAbstractionTerm v)-existingPath;
::end;
::
::registration
::  let v;
::
::  cluster AbsLoc -> v-existingVarPath;
::::>                                 *100
::  coherence;
::::>       *4
::end;

definition
  let v,M;

  func Abs(v,M) -> LambdaTerm equals
:: LAMBDA:def 12

    (PreAbstractionTerm v) with-replacement (<*0*>, M);

::  func Abs(v,M) -> LambdaTerm means
::    it,(<*> NAT) abstracts v &
::    it|<*0*> = M &
::    not <*1*> in dom it;
::  existence
::  proof
::    set e = <*> NAT;
::    set e0 = <*0*>;
::    set e1 = <*1*>;
::  A3: not e0,e1 are_c=-comparable
::    proof
::      assume e0,e1 are_c=-comparable;
::      then 0 = 1 by TREES_1:5;
::      hence contradiction;
::    end;
::
::  A6: dom (PreAbstractionTerm v) = { {}, <*0*> } by FUNCOP_1:13;
::    then <*0*> in dom (PreAbstractionTerm v) by TARSKI:def 2;
::    then reconsider e0 as Element of dom (PreAbstractionTerm v);
::    set D = (PreAbstractionTerm v) with-replacement (e0, M);
::
::    take D;
::    thus D,e abstracts v
::    proof
::      thus thesis;
::::>             *4
::    end;
::
::    thus D|<*0*> = M by Th3;
::    thus not <*1*> in dom D
::    proof
::      assume e1 in dom D;
::      then e1 in (dom (PreAbstractionTerm v)) with-replacement (e0, dom M)
::        by TREES_2:def 11;
::      then
::    A4: (e1 in (dom (PreAbstractionTerm v)) & not e0 is_a_proper_prefix_of e1)
::     or (ex r st r in dom M & e1 = e0^r)
::        by TREES_1:def 9;
::      (e1 in (dom (PreAbstractionTerm v)) & not e0 is_a_proper_prefix_of e1)
::      proof
::        assume not thesis;
::        then (ex r st r in dom M & e1 = e0^r) by A4;
::        then consider r such that r in dom M and
::      A2: e1 = e0^r;
::        e0 is_a_prefix_of e1 by A2, TREES_1:1;
::        then e0,e1 are_c=-comparable by XBOOLE_0:def 9;
::        hence contradiction by A3;
::      end;
::      then
::    A5: e1 in (dom (PreAbstractionTerm v));
::      then
::    A7: e1 = {} or e1 = <*0*> by A6, TARSKI:def 2;
::      per cases;
::      suppose e1 = {};
::        then e1 is empty;
::        hence contradiction;
::      end;
::      suppose not e1 = {};
::        then e1 = <*0*> by A7;
::        then
::      A8: e1.1 = 0 by FINSEQ_1:40;
::        e1.1 = 1 by FINSEQ_1:40;
::        hence contradiction by A8;
::      end;
::    end;
::  end;
::  uniqueness;
::::>        *4
end;

definition
  let M,N;

  func App(M,N) -> LambdaTerm equals
:: LAMBDA:def 13

    (PreApplicationTerm
      with-replacement (<*0*>, M)
    )
      with-replacement (<*1*>, N);

::  func App(M,N) -> LambdaTerm means
::    it|<*0*> = M & it|<*1*> = N;
::  existence
::  proof
::    set e0 = <*0*>;
::    set e1 = <*1*>;
::  A3: not e0,e1 are_c=-comparable
::    proof
::      assume e0,e1 are_c=-comparable;
::      then 0 = 1 by TREES_1:5;
::      hence contradiction;
::    end;
::  A4: not e0 is_a_proper_prefix_of e1 by A3, Th6;
::
::    dom PreApplicationTerm = { {}, <*0*>, <*1*> } by FUNCOP_1:13;
::    then
::  A7: <*0*> in dom PreApplicationTerm by ENUMSET1:def 1;
::    then reconsider e0 as Element of dom PreApplicationTerm;
::    set preD = PreApplicationTerm with-replacement (e0, M);
::    preD is LambdaTerm;
::
::  A1: dom preD = (dom PreApplicationTerm) with-replacement (e0, dom M)
::      by TREES_2:def 11;
::    dom PreApplicationTerm = { {}, <*0*>, <*1*> } by FUNCOP_1:13;
::    then
::  A2: <*1*> in dom PreApplicationTerm by ENUMSET1:def 1;
::    <*1*> in dom preD by A1, A2, A4, TREES_1:def 9;
::    then reconsider e1 as Element of dom preD;
::    set D = preD with-replacement (e1, N);
::    D is LambdaTerm;
::
::  A6: e0 in dom preD
::    proof
::    A8: e0 in dom PreApplicationTerm by A7;
::      not e0 is_a_proper_prefix_of e0;
::      then e0 in (dom PreApplicationTerm) with-replacement (e0, dom M)
::        by A8, TREES_1:def 9;
::      hence thesis by A1, TREES_2:def 11;
::    end;
::  A5: e0 in dom D
::    proof
::    A9: e0 in dom preD by A6;
::      not e1 is_a_proper_prefix_of e0 by A3, Th6;
::      then e0 in (dom preD) with-replacement (e1, dom N)
::        by A9, TREES_1:def 9;
::      hence thesis by A1, TREES_2:def 11;
::    end;
::
::    take D;
::    thus D|<*0*> = preD|<*0*> by A3, A5, A6, Th5
::                .= M by Th3;
::    thus D|<*1*> = N by Th3;
::  end;
::  uniqueness;
::::>        *4
end;

::: ### Substitution

definition
  let N,M,v;

  redefine func (N,v) <- M -> LambdaTerm;
end;

::: #### Substitution lemma
::: (If I have time...)

theorem :: LAMBDA:9
  not P contains_variable v implies
    ::M[v := N][w := P] =
    (((M,v) <- N),w) <- P =
    (((M,w) <- P),v) <- ((N,w) <- P);

::: ### Reduction and conversion

::: First we define one-step toplevel (_shallow_) reduction.

definition
  let P,Q;

  :: P === (\x.N)M --> N[x:=M] === Q
  pred P beta->shallow Q means
:: LAMBDA:def 14
    ex N,n,M st
      :: P === (\x.N)M
      P = App(Abs(n,N),M) &

      :: Q === N[x:=M]
      Q = (N,n) <- M;
end;

::: Then we close under subterm reduction to get actual one-step beta reduction.

::: Note that I had to use a work-around here, where I have two
:::  set-theoretically identical elements `p` and `q`, but considered
:::  in Mizar as having different types to enable the two `|` operations
:::  to work. I also tried defining something like `Element of (dom M),(dom N)`,
:::  but this is extremely difficult, if not impossible.
definition
  let M,N;

  :: TODO better definition with tree operations ?

  pred M beta-> N means
:: LAMBDA:def 15
    ex
      p being Element of dom M,
      q being Element of dom N st
        p = q &
        M|p beta->shallow N|q &
        for q st not p is_a_prefix_of q holds
          [r,x] in M iff [r,x] in N;
end;

::: We close under transitivity and reflexivity
:::  to get full beta reduction.
definition
  let M,N;

  pred M beta->* N means
:: LAMBDA:def 16
    M = N or
    ex P st M beta-> P & P beta-> N;
end;

::: And then close under symmetry to get beta conversion.
definition
  let M,N;

  pred M beta= N means
:: LAMBDA:def 17
    M beta->* N or N beta->* M;
end;

::: As a note of victory, let's just define some terms! :)
definition
  func cI -> LambdaTerm equals
:: LAMBDA:def 18

    Abs(0,Var(0));

  func cOne -> LambdaTerm equals
:: LAMBDA:def 19

    Abs(0,Abs(1,App(Var(0),Var(1))));

  func cK -> LambdaTerm equals
:: LAMBDA:def 20

    Abs(0,Abs(1,Var(0)));

  func cK* -> LambdaTerm equals
:: LAMBDA:def 21

    Abs(0,Abs(1,Var(1)));

  func cDelta -> LambdaTerm equals
:: LAMBDA:def 22

    Abs(0,App(Var(0),Var(0)));

  func cY -> LambdaTerm equals
:: LAMBDA:def 23

    Abs(1,App(
      Abs(0,App(Var(1),App(Var(0),Var(0)))),
      Abs(0,App(Var(1),App(Var(0),Var(0))))
    ));
end;

definition
  func cOmega -> LambdaTerm equals
:: LAMBDA:def 24

    App(cDelta,cDelta);
end;

::>
::> 4: This inference is not accepted
::> 60: Something remains to be proved in this case
