::: # Lambda calculus

::: Original files:
:::  [.abs](text/lambda.abs),
:::  [.miz](text/lambda.miz),
:::  [.voc](dict/lambda.voc)

::: @TOC

::: TODO note how we almost never work by inductive/recursive means,
:::  in constract with, say, Coq.

:: Environ originally taken from `finseq_2`. Later, I added trees and orders.
environ

  :: Vocabularies are basically for Mizar's lexer.
  vocabularies LAMBDA,
    FINSET_1,
    NUMBERS,
    NAT_1, XBOOLE_0, SUBSET_1, FINSEQ_1, XXREAL_0, CARD_1,
    ARYTM_1, ARYTM_3, TARSKI, ORDINAL4, FUNCOP_1,
    RELAT_2, RELAT_1,
    FUNCT_1, FUNCT_2,
    ZFMISC_1, PARTFUN1,
    ORDERS_2, ORDERS_1,
    FINSEQ_2, FINSEQ_4, PBOOLE, CARD_3, VALUED_1,
    TREES_1, TREES_2, TREES_3, TREES_4;

  :: Radix type specifications
  :: But it also helped [175 unknown attribute format] error with [finite set]
  notations FINSET_1,
    TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1,
    NUMBERS, XCMPLX_0, DOMAIN_1, NAT_1, RELAT_1, PARTFUN1,
    RELAT_2, RELSET_1,
    FUNCT_1, FUNCT_2,
    FUNCT_3, FINSEQ_1, FINSEQ_2, BINOP_1, PBOOLE, FUNCOP_1, CARD_3,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ORDERS_1, ORDERS_2,
    XXREAL_0, VALUED_1,
    RECDEF_1;

  :: For modes? (unknown mode format resolved)
  constructors RELAT_2, RELAT_1,
    PARTFUN1, BINOP_1, DOMAIN_1,
    FUNCT_1, FUNCT_2, FUNCT_3,
    FUNCOP_1,
    RELSET_1,
    SQUARE_1, NAT_1, FINSEQ_1, FINSEQ_2, PBOOLE, CARD_3, VALUED_1, SETFAM_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ORDERS_1, ORDERS_2,
    RECDEF_1,
    FINSET_1,
    ENUMSET1,
    WELLORD2;

  :: Definition are for automatically unfolding predicates
  ::  in the thesis you are proving
  definitions TARSKI,
    FUNCT_1, FUNCT_2,
    FINSEQ_1, CARD_1, PBOOLE, FUNCOP_1,
    ORDERS_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    ::XTUPLE_0;
    MCART_1; ::, FUNCT_5, RECDEF_1;

  :: Registrations are for clusters (showing that a type exists (is non-empty),
  ::  and automatically adding adjectives)
  registrations XBOOLE_0, SUBSET_1, ORDINAL1, PARTFUN1,
    ::RELAT_2,
    RELAT_1,
    FUNCT_1, FUNCT_2,
    FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, FINSEQ_2, CARD_1, RELSET_1,
    PBOOLE, CARD_3,
    ORDERS_2,
    TREES_1, TREES_2, TREES_3, TREES_4,
    FINSET_1;

  :: Load theorem en definition labels
  theorems FUNCOP_1, RELAT_1, TARSKI, FINSEQ_1, FINSEQ_2,
    ::XTUPLE_0,
    MCART_1, FUNCT_5, :: RECDEF_1,
    FUNCT_1,
    TREES_1, TREES_2, TREES_3, TREES_4,
    XBOOLE_0, SUBSET_1, RELAT_2, ENUMSET1,
    CARD_1, CARD_2, CARD_3, CARD_4;

  schemes RECDEF_1, TREES_2, TREES_4;

  requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

begin

::: ## Syntax and behaviour

definition
  mode Variable is Element of NAT;
end;

reserve T,T1,T2 for Tree,
        D,D2 for DecoratedTree,
        p,q,q0,q1,q2,r for FinSequence of NAT,
        x,y,X,Y for set,
        i,j,k,l,m,n for Element of NAT,
        u,v,w for Variable;

::: ### Lambda terms

::: A _lambda term_ is identified with it's AST (abstract
:::  syntax tree). More precisely, we identify a lambda term
:::  with a finite decorated tree.
::: The nodes of the tree denote either application, abstraction
:::  or a variable. Using _De Bruijn_ variable indexing, we decorate
:::  variables with their De Bruijn index (a natural nuber). Note
:::  that we needn't explicitly annotate the type of a node,
:::  as the three types of nodes differ in how many children they must
:::  have: an application always has two children, an abstraction but one,
:::  and variables don't have any. So it suffices to decorate application
:::  and abstraction nodes with some default value (say, $0$).

::: In Mizar, a `Tree` is a non-empty subset of `NAT*`, so a set of finite
:::  sequences of natural numbers, such that certain logical properties hold.
::: Every such sequence denotes a node in the tree, and can be interpreted
:::  as a _path specification_ (how to get there, from the top). We see, then,
:::  that lambda term trees are a specific subset of general trees, in which
:::  only finite sequences of $\\{0,1\\}$ are used to denote nodes, nodes
:::  with children are decorated with a $0$, and is also finite in height.
::: By _decorating_ a node `r` with a number `n`, we mean that `M.r = n`.
::: Here `M` is the `DecoratedTree of NAT` which represents the lambda term.

definition
  let D;

  attr D is LambdaTerm-like means
:: LAMBDA:def 1

    dom D is finite &
    for r st r in dom D holds
      r is FinSequence of {0,1} &
      ((r^<*0*> in dom D & r^<*1*> in dom D)
          implies D.r = 0);
end;

::: Some simple `LambdaTerm-like` things.

::: TODO: some more of these simple trees, for easy usage
:::  later on, when defining application and abstraction.

registration
  let v;

  cluster { {} } --> v -> LambdaTerm-like;
end;

registration
  cluster { <*> NAT } -> Tree-like;
end;

registration
  let v;

  cluster { <*> NAT } --> v -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*> } -> Tree-like;
end;

registration
  let v;

  cluster { {}, <*0*> } --> v -> LambdaTerm-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } -> Tree-like;
end;

registration
  cluster { {}, <*0*>, <*1*> } --> 0 -> LambdaTerm-like;
end;

::: And then we can easily define a `LambdaTerm-like` cluster,
:::  and make a mode `LambdaTerm` out of it.
registration
  cluster LambdaTerm-like for DecoratedTree of NAT;
end;

definition
  mode LambdaTerm is LambdaTerm-like DecoratedTree of NAT;
end;

definition
  let v;

  func PreAbstractionTerm v -> LambdaTerm equals
:: LAMBDA:def 2
    { {}, <*0*> } --> v;
end;

definition
  func PreApplicationTerm -> LambdaTerm equals
:: LAMBDA:def 3
    { {}, <*0*>, <*1*> } --> 0;
end;

reserve M,N,P,Q for LambdaTerm;

::: #### Preservation under operations

::: `LambdaTerm`s are preserved under taking subterms, and composing
:::  terms. We'll register this knowledge in the type system.

::: Let Mizar know that `M|r` is also a `LambdaTerm`.
::: The definition of `|` that we are using is the definition
:::  that operates on (and returns) a `DecoratedTree`. Showing
:::  that retricting a `LambdaTerm` produces a `LambdaTerm-like`
:::  result ensures us that the result is a `LambdaTerm`.
registration
  let M be LambdaTerm,
      r be Element of dom M;

  cluster M|r -> LambdaTerm-like;
end;

::: Let Mizar know that `P with-replacement (p,Q)` is also a `LambdaTerm`.
::: First we prove a slightly more general theorem about the ranges of
:::  composed `DecoratedTree`s, and add this knowledge to the type system.
reserve X for set,
        D1,D2 for DecoratedTree,
        p for Element of dom D1;

theorem :: LAMBDA:1
  D1 is X-valued & D2 is Y-valued implies
    D1 with-replacement (p,D2) is (X \/ Y)-valued;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> NAT-valued;
end;

reserve p for Element of dom P;

theorem :: LAMBDA:2
  P with-replacement (p,Q) is LambdaTerm-like;

registration
  let P,Q be LambdaTerm,
      p be Element of dom P;

  cluster P with-replacement (p,Q) -> LambdaTerm-like;
end;

definition
  let P be LambdaTerm,
      p be Element of dom P,
      Q be LambdaTerm;

  redefine func P with-replacement (p,Q) -> LambdaTerm;
end;

::: ### Helper definitions
::: Some helper definitions for working with lambda terms.

::: #### Variable occurences
definition
  let M be LambdaTerm,
      r; :: be Node of M;

  pred r is_variable_in M means
:: LAMBDA:def 4

    r in dom M &
    not r^<*0*> in dom M;

  pred r is_abstraction_in M means
:: LAMBDA:def 5

    r in dom M &
    r^<*0*> in dom M & not r^<*1*> in dom M;

  pred r is_application_in M means
:: LAMBDA:def 6

    r in dom M &
    r^<*0*> in dom M & r^<*1*> in dom M;
end;

definition
  let M,r,v;

  pred M,r holds_variable v means
:: LAMBDA:def 7

    r is_variable_in M &
    M.r = n;

  pred M,r abstracts v means
:: LAMBDA:def 8

    r is_abstraction_in M &
    M.r = n;
end;

definition
  let M,v;

  pred M contains_variable v means
:: LAMBDA:def 9

    ex r st M,r holds_variable v;
end;

::: #### Abstraction and application

definition
  let v;

  func Var(v) -> LambdaTerm equals
:: LAMBDA:def 10

    { <*> NAT } --> v;
end;

::: Then we can define abstraction and application
definition
  let v,M;

  func Abs(v,M) -> LambdaTerm means
:: LAMBDA:def 11
    it,(<*> NAT) abstracts v &
    it|<*0*> = M &
    not <*1*> in dom it;
::>        *4
end;

definition
  let M,N;

  func App(M,N) -> LambdaTerm means
:: LAMBDA:def 12
    it|<*0*> = M & it|<*1*> = N;
::>        *4
end;

::: ### Substitution

definition
  let N,M,v;

  redefine func (N,v) <- M -> LambdaTerm;
end;

::: #### Substitution lemma
::: (If I have time...)

theorem :: LAMBDA:3
  not P contains_variable v implies
    ::M[v := N][w := P] =
    (((M,v) <- N),w) <- P =
    (((M,w) <- P),v) <- ((N,w) <- P);

::: ### Reduction and conversion

::: First we define one-step toplevel (_shallow_) reduction.

definition
  let P,Q;

  :: P === (\x.N)M --> N[x:=M] === Q
  pred P beta->shallow Q means
:: LAMBDA:def 13
    ex N,n,M st
      :: P === (\x.N)M
      P = App(Abs(n,N),M) &

      :: Q === N[x:=M]
      Q = (N,n) <- M;
end;

::: Then we close under subterm reduction to get actual one-step beta reduction.

::: Note that I had to use a work-around here, where I have two
:::  set-theoretically identical elements `p` and `q`, but considered
:::  in Mizar as having different types to enable the two `|` operations
:::  to work. I also tried defining something like `Element of (dom M),(dom N)`,
:::  but this is extremely difficult, if not impossible.
definition
  let M,N;

  :: TODO better definition with tree operations ?

  pred M beta-> N means
:: LAMBDA:def 14
    ex
      p being Element of dom M,
      q being Element of dom N st
        p = q &
        M|p beta->shallow N|q &
        for q st not p is_a_prefix_of q holds
          [r,x] in M iff [r,x] in N;
end;

::: We close under transitivity and reflexivity
:::  to get full beta reduction.
definition
  let M,N;

  pred M beta->* N means
:: LAMBDA:def 15
    M = N or
    ex P st M beta-> P & P beta-> N;
end;

::: And then close under symmetry to get beta conversion.
definition
  let M,N;

  pred M beta= N means
:: LAMBDA:def 16
    M beta->* N or N beta->* M;
end;

::: As a note of victory, let's just define some terms! :)
definition
  func cI -> LambdaTerm equals
:: LAMBDA:def 17

    Abs(0,Var(0));

  func cOne -> LambdaTerm equals
:: LAMBDA:def 18

    Abs(0,Abs(1,App(Var(0),Var(1))));

  func cK -> LambdaTerm equals
:: LAMBDA:def 19

    Abs(0,Abs(1,Var(0)));

  func cK* -> LambdaTerm equals
:: LAMBDA:def 20

    Abs(0,Abs(1,Var(1)));

  func cDelta -> LambdaTerm equals
:: LAMBDA:def 21

    Abs(0,App(Var(0),Var(0)));

  func cY -> LambdaTerm equals
:: LAMBDA:def 22

    Abs(1,App(
      Abs(0,App(Var(1),App(Var(0),Var(0)))),
      Abs(0,App(Var(1),App(Var(0),Var(0))))
    ));
end;

definition
  func cOmega -> LambdaTerm equals
:: LAMBDA:def 23

    App(cDelta,cDelta);
end;

::>
::> 4: This inference is not accepted
::> 51: Invalid conclusion
