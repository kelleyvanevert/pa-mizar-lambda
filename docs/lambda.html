<!DOCTYPE html>

<html>
<head>
  <title>lambda.miz</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>lambda.miz</h1>
                  
                  <ul class="originals">
                    <li>mizar files:</li>
                    <li><a href="lambda.miz">.miz</a></li>
                    <li><a href="lambda.voc">.voc</a></li>
                  </ul>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2>Lambda calculus</h2>
<p>Environ originally taken from <code>finseq_2</code>. Later, I added trees and orders.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">environ</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Vocabularies are basically for Mizar&#39;s lexer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">vocabularies</span> LAMBDA,
      FINSET_1,
      NUMBERS,
      NAT_1, XBOOLE_0, SUBSET_1, FINSEQ_1, XXREAL_0, CARD_1,
      ARYTM_1, ARYTM_3, TARSKI, ORDINAL4, FUNCOP_1,
      RELAT_2, RELAT_1,
      FUNCT_1, FUNCT_2,
      ZFMISC_1, PARTFUN1,
      ORDERS_2, ORDERS_1,
      FINSEQ_2, PBOOLE, CARD_3, VALUED_1,
      TREES_2, TREES_1;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Radix type specifications
But it also helped [175 unknown attribute format] error with [finite set]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">notations</span> FINSET_1,
      TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1,
      NUMBERS, XCMPLX_0, DOMAIN_1, NAT_1, RELAT_1, PARTFUN1,
      RELAT_2, RELSET_1,
      FUNCT_1, FUNCT_2,
      FUNCT_3, FINSEQ_1, BINOP_1, PBOOLE, FUNCOP_1, CARD_3,
      TREES_2, TREES_1,
      ORDERS_1, ORDERS_2,
      XXREAL_0, VALUED_1,
      RECDEF_1;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>For modes? (unknown mode format resolved)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">constructors</span> RELAT_2, RELAT_1,
      PARTFUN1, BINOP_1, DOMAIN_1,
      FUNCT_1, FUNCT_2, FUNCT_3,
      FUNCOP_1,
      RELSET_1,
      SQUARE_1, NAT_1, FINSEQ_1, PBOOLE, CARD_3, VALUED_1, SETFAM_1,
      TREES_2, TREES_1,
      ORDERS_1, ORDERS_2,
      RECDEF_1;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Definition are for automatically unfolding predicates in the thesis you are proving</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">definitions</span> TARSKI,
      FUNCT_1, FUNCT_2,
      FINSEQ_1, CARD_1, PBOOLE, FUNCOP_1,
      ORDERS_1,
      TREES_2, TREES_1;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Registrations are for clusters (showing that a type exists (is non-empty),
 and automatically adding adjectives)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">registrations</span> XBOOLE_0, SUBSET_1, ORDINAL1, PARTFUN1,
      RELAT_2, RELAT_1,
      FUNCT_1, FUNCT_2,
      FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, CARD_1, RELSET_1,
      PBOOLE, CARD_3,
      ORDERS_2,
      TREES_2, TREES_1;

  <span class="keyword">schemes</span> RECDEF_1;

  <span class="keyword">requirements</span> BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

<span class="keyword">begin</span>

<span class="keyword">reserve</span> D <span class="keyword">for</span> DecoratedTree,
        p,q,r <span class="keyword">for</span> FinSequence <span class="keyword">of</span> NAT,
        x <span class="keyword">for</span> <span class="keyword">set</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Lambda terms</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">::</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A <em>lambda term</em> is identified with it&#39;s AST (abstract
 syntax tree). More precisely, we identify a lambda term
 with a finite decorated tree.
The nodes of the tree denote either application, abstraction
 or a variable. Using <em>De Bruijn</em> variable indexing, we decorate
 variables with their De Bruijn index (a natural nuber). Note
 that we needn&#39;t explicitly annotate the type of a node,
 as the three types of nodes differ in how many children they must
 have: an application always has two children, an abstraction but one,
 and variables don&#39;t have any. So it suffices to decorate application
 and abstraction nodes with some default value (say, $0$).</p>
<p>In Mizar, a <code>Tree</code> is a non-empty subset of <code>NAT*</code>, so a set of finite
 sequences of natural numbers, such that certain logical properties hold.
Every such sequence denotes a node in the tree, and can be interpreted
 as a <em>path specification</em> (how to get there, from the top). We see, then,
 that lambda term trees are a specific subset of general trees, in which
 only finite sequences of $\{0,1\}$ are used to denote nodes, nodes
 with children are decorated with a $0$, and is also finite in height.
By <em>decorating</em> a node <code>r</code> with a number <code>n</code>, we mean that <code>M.r = n</code>.
Here <code>M</code> is the <code>DecoratedTree of NAT</code> which represents the lambda term.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> D;
  
  <span class="keyword">attr</span> D <span class="keyword">is</span> LambdaTerm-like <span class="keyword">means</span>
    (dom D qua Tree) <span class="keyword">is</span> finite &amp;
    <span class="keyword">for</span> r <span class="keyword">st</span> r <span class="keyword">in</span> dom D <span class="keyword">holds</span>
      r <span class="keyword">is</span> FinSequence <span class="keyword">of</span> {0,1} &amp;
      r^&lt;*0*&gt; <span class="keyword">in</span> dom D <span class="keyword">implies</span> D.r = 0;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Here, I am having some troubles with Mizar types. I want to follow
 the general MML pattern of first defining an attribute <code>LambdaTerm-like</code>,
 and then a mode <code>LambdaTerm</code> which is simply a <code>LambdaTerm-like DecoratedTree
 of NAT</code>. But then first, I must show that this is a existence cluster, and thus
 I must show that such a decoratedtree actually exists...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">registration</span>
  <span class="keyword">cluster</span> LambdaTerm-like <span class="keyword">for</span> DecoratedTree <span class="keyword">of</span> NAT;
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">mode</span> LambdaTerm <span class="keyword">is</span> LambdaTerm-like DecoratedTree <span class="keyword">of</span> NAT;
<span class="keyword">end</span>;

<span class="keyword">reserve</span> M,N,P,Q <span class="keyword">for</span> LambdaTerm;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Let Mizar know that <code>M|r</code> is also a <code>LambdaTerm</code>.
The definition of <code>|</code> that we are using is the definition
 that operates on (and returns) a <code>DecoratedTree</code>. Showing
 that retricting a <code>LambdaTerm</code> produces a <code>NAT-valued</code> result
 ensures that the result is then a <code>DecoratedTree of NAT</code>;
 which then together with <code>LambdaTerm-like</code> means that it is
 indeed a <code>LambdaTerm</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">registration</span>
  <span class="keyword">let</span> M,r;

  <span class="keyword">cluster</span> M|r -&gt; NAT-valued LambdaTerm-like;
  <span class="keyword">coherence</span>;
<span class="comment">::&gt;       *4,4</span>
<span class="keyword">end</span>;

<span class="keyword">theorem</span>
  (M|r qua DecoratedTree <span class="keyword">of</span> NAT) <span class="keyword">is</span> LambdaTerm
<span class="keyword">proof</span>
  <span class="keyword">thus</span> <span class="keyword">thesis</span>;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Some helper definitions for working with lambda terms.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> M,r;
  
  <span class="keyword">pred</span> r is_variable_in M <span class="keyword">means</span>
    <span class="keyword">not</span> r^&lt;*0*&gt; <span class="keyword">in</span> dom M;

  <span class="keyword">pred</span> r is_abstraction_in M <span class="keyword">means</span>
    r^&lt;*0*&gt; <span class="keyword">in</span> dom M &amp; <span class="keyword">not</span> r^&lt;*1*&gt; <span class="keyword">in</span> dom M;

  <span class="keyword">pred</span> r is_application_in M <span class="keyword">means</span>
    r^&lt;*0*&gt; <span class="keyword">in</span> dom M &amp; r^&lt;*1*&gt; <span class="keyword">in</span> dom M;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>By $r$ being an <em>active variable</em> of some term $M$ (or more precisely,
 a path identifying an active variable), I mean that if $\lambda M$ were
 to be applied to some other term $N$, we would substitute this variable
 by $M$.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> M,r;
  
  <span class="keyword">pred</span> r is_active_variable_in M <span class="keyword">means</span>
    r is_variable_in M &amp;
    M.r = card { p where p <span class="keyword">is</span> Element <span class="keyword">of</span> dom M
                 : p is_a_proper_prefix_of r &amp;
                   p is_abstraction_in M };
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> M;
  
  <span class="keyword">func</span> Abs(M) -&gt; LambdaTerm <span class="keyword">means</span>
    it|&lt;*0*&gt; = M &amp; <span class="keyword">not</span> &lt;*0*&gt; <span class="keyword">in</span> dom it;
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
  <span class="keyword">uniqueness</span>;
<span class="comment">::&gt;        *4</span>
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> M,N;

  <span class="keyword">func</span> App(M,N) -&gt; LambdaTerm <span class="keyword">means</span>
    it|&lt;*0*&gt; = M &amp; it|&lt;*1*&gt; = N;
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
  <span class="keyword">uniqueness</span>;
<span class="comment">::&gt;        *4</span>
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> M,N;

  <span class="keyword">func</span> SubstituteActiveVar(M,N) -&gt; LambdaTerm <span class="keyword">means</span>
    <span class="comment">:: most things are the same,</span>
    (<span class="keyword">for</span> r <span class="keyword">st</span> <span class="keyword">not</span> (<span class="keyword">ex</span> p <span class="keyword">st</span> p is_active_variable_in N &amp;
                           p is_a_prefix_of r)
           <span class="keyword">holds</span> [r,x] <span class="keyword">in</span> it <span class="keyword">iff</span> [r,x] <span class="keyword">in</span> N
    ) &amp;
    <span class="comment">:: except that the active variables are replaced with M</span>
    (<span class="keyword">for</span> r <span class="keyword">st</span> r is_active_variable_in N <span class="keyword">holds</span> it|r = M);
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
  <span class="keyword">uniqueness</span>;
<span class="comment">::&gt;        *4</span>
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3>Reduction and conversion</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">::</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>First I define <em>shallow</em> one-step beta substitution, which only
 states (the De Bruijn equivalent of)
 $(\lambda x.N)M \to_{\beta} N[x:=M]$.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> P,Q;
  
  <span class="comment">:: P === (\x.N)M --&gt; N[x:=M] === Q</span>
  <span class="keyword">pred</span> P beta_shallow Q <span class="keyword">means</span>
    <span class="keyword">ex</span> M,N <span class="keyword">st</span>
      <span class="comment">:: P === (\x.N)M</span>
      P = App(Abs(N),M) &amp;

      <span class="comment">:: Q === N[x:=M]</span>
      Q = SubstituteActiveVar(N,M);
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Then we extend this ordinary one-step beta reduction, that is,
 any subterm is also allowed to reduce.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> M,N;

  <span class="keyword">pred</span> M beta N <span class="keyword">means</span>
    <span class="keyword">ex</span> p <span class="keyword">st</span>
      M|p beta_shallow N|p &amp;
      <span class="keyword">for</span> q <span class="keyword">st</span> <span class="keyword">not</span> p is_a_prefix_of q <span class="keyword">holds</span>
        [r,x] <span class="keyword">in</span> M <span class="keyword">iff</span> [r,x] <span class="keyword">in</span> N;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>We close the relation under transitivity and reflexivity
 to get the full beta reduction relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> M,N;
  
  <span class="keyword">pred</span> M beta* N <span class="keyword">means</span>
    M = N <span class="keyword">or</span>
    <span class="keyword">ex</span> P <span class="keyword">st</span> M beta P &amp; P beta N;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>And then close under symmetry to get beta conversion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> M,N;
  
  <span class="keyword">pred</span> M beta= N <span class="keyword">means</span>
    M beta* N <span class="keyword">or</span> N beta* M;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h3>CPO&#39;s</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">::</span>

<span class="keyword">reserve</span> x,y,z,z2 <span class="keyword">for</span> <span class="keyword">set</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>We start off by defining
 a mode for partial orders upon some set <code>D</code>. I don&#39;t really
 get why de Mizar guys wrote their order definition the way
 they did (in <code>ORDERS_1</code>, <code>ORDERS_2</code>, etc...)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">mode</span> PartialOrder <span class="keyword">is</span> transitive reflexive antisymmetric Relation;
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>;
  <span class="keyword">mode</span> PartialOrder <span class="keyword">of</span> D <span class="keyword">is</span> transitive reflexive antisymmetric (Relation <span class="keyword">of</span> D);
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><strong>(Least) upper bounds</strong></p>
<p>An element $u$ of $D$ is an <em>upper bound</em> of a
 subset $X\subseteq D$ iff for all $x\in X$,
 $x\sqsubseteq u$.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> PartialOrder <span class="keyword">of</span> D,
      X <span class="keyword">be</span> Subset <span class="keyword">of</span> D,
      u <span class="keyword">be</span> Element <span class="keyword">of</span> D;

  <span class="keyword">attr</span> u <span class="keyword">is</span> X-ub <span class="keyword">means</span>
<span class="comment">::&gt;            *100</span>
    u=u &amp; <span class="keyword">for</span> x <span class="keyword">st</span> x <span class="keyword">in</span> X <span class="keyword">holds</span> [x,u] <span class="keyword">in</span> R;
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> PartialOrder <span class="keyword">of</span> D,
      X <span class="keyword">be</span> Subset <span class="keyword">of</span> D,
      u <span class="keyword">be</span> Element <span class="keyword">of</span> D;

  <span class="keyword">pred</span> u is_ub_of X <span class="keyword">means</span>
<span class="comment">::&gt;             *100</span>
    <span class="keyword">for</span> x <span class="keyword">st</span> x <span class="keyword">in</span> X <span class="keyword">holds</span> [x,u] <span class="keyword">in</span> R;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Define least upper bounds</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> transitive reflexive antisymmetric Relation,
      X <span class="keyword">be</span> R-directed Subset <span class="keyword">of</span> D,
<span class="comment">::&gt;                 *175   *151</span>
      u <span class="keyword">be</span> Element <span class="keyword">of</span> D;

  <span class="keyword">attr</span> u <span class="keyword">is</span> X-lub <span class="keyword">means</span>
    u <span class="keyword">is</span> X-ub &amp;
    <span class="keyword">for</span> u2 <span class="keyword">being</span> Element <span class="keyword">of</span> D <span class="keyword">st</span> u2 <span class="keyword">is</span> X-ub <span class="keyword">holds</span>
      u = u2;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p><strong>Directed sets</strong></p>
<p>If $D$ is a set, and $R$ a partial order on $D$,
 then an $X\subseteq D$ is called <em>directed</em> iff
 for all $x,y \in X$, there is some $z \in X$,
 such that $x\sqsubseteq z$ and $y\sqsubseteq z$.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> PartialOrder <span class="keyword">of</span> D,
      X <span class="keyword">be</span> Subset <span class="keyword">of</span> D;

  <span class="keyword">attr</span> X <span class="keyword">is</span> R-directed <span class="keyword">means</span>
    <span class="keyword">for</span> x,y <span class="keyword">st</span> x <span class="keyword">in</span> X &amp; y <span class="keyword">in</span> X <span class="keyword">holds</span>
      <span class="keyword">ex</span> z <span class="keyword">st</span>
        z <span class="keyword">in</span> X &amp; [x,z] <span class="keyword">in</span> R &amp; [y,z] <span class="keyword">in</span> R;
<span class="keyword">end</span>;

<span class="keyword">registration</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> PartialOrder <span class="keyword">of</span> D;

  <span class="keyword">cluster</span> R-directed <span class="keyword">for</span> Subset <span class="keyword">of</span> D;
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><strong>Completeness</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> transitive reflexive antisymmetric Relation;

  <span class="keyword">attr</span> R <span class="keyword">is</span> D-complete <span class="keyword">means</span>
    <span class="keyword">for</span> X <span class="keyword">being</span> R-directed Subset <span class="keyword">of</span> D <span class="keyword">holds</span>
<span class="comment">::&gt;                      *115</span>
      <span class="keyword">ex</span> u <span class="keyword">being</span> Element <span class="keyword">of</span> D <span class="keyword">st</span> u <span class="keyword">is</span> X-lub;
<span class="comment">::&gt;                                       *106</span>
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Here again, what I want to express is that such complete partial
 orders exist, not that for every $D$, any partial order is $D$-complete,
 or something weird like that...</p>
<p>What are the precise semantics of these clusters?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">registration</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>;

  <span class="keyword">cluster</span> D-complete <span class="keyword">for</span> transitive reflexive antisymmetric Relation;
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> D-complete transitive reflexive antisymmetric Relation,
      X <span class="keyword">be</span> R-directed Subset <span class="keyword">of</span> D;
<span class="comment">::&gt;                 *115</span>

  <span class="keyword">func</span> LUB(X) -&gt; Element <span class="keyword">of</span> D <span class="keyword">means</span>
<span class="comment">::&gt;      *100</span>
    it <span class="keyword">is</span> X-lub;
<span class="comment">::&gt;           *106</span>
  <span class="keyword">existence</span>;
  <span class="keyword">uniqueness</span>;
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> <span class="keyword">set</span>,
      R <span class="keyword">be</span> transitive reflexive antisymmetric Relation,
      x <span class="keyword">be</span> Element <span class="keyword">of</span> D;

  <span class="keyword">attr</span> x <span class="keyword">is</span> D-bottom <span class="keyword">means</span>
<span class="comment">::&gt;                *100</span>
    <span class="keyword">for</span> y <span class="keyword">st</span> y <span class="keyword">in</span> D <span class="keyword">holds</span> [x,y] <span class="keyword">in</span> R;
<span class="keyword">end</span>;

<span class="keyword">registration</span>
  <span class="keyword">let</span> R <span class="keyword">be</span> transitive reflexive antisymmetric Relation,
      X <span class="keyword">be</span> <span class="keyword">set</span>;

  <span class="keyword">cluster</span> R-bottom <span class="keyword">for</span> Element <span class="keyword">of</span> X;
<span class="comment">::&gt;              *106,115    *100</span>
  <span class="keyword">existence</span>;
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">struct</span> CPO (#
    carrier -&gt; <span class="keyword">set</span>,

    <span class="comment">:: complete partial order</span>
    BinRel -&gt; (the carrier)-complete
      transitive reflexive antisymmetric
      (Relation <span class="keyword">of</span> the carrier, the carrier),
<span class="comment">::&gt;           *136</span>
    
    <span class="comment">:: with bottom element</span>
    Bot -&gt; (the BinRel)-bottom Element <span class="keyword">of</span> the carrier
<span class="comment">::&gt;                          *115    *136</span>
  #);
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> CPO,
      f <span class="keyword">be</span> Function <span class="keyword">of</span> D,D;

  <span class="keyword">attr</span> f <span class="keyword">is</span> monotone <span class="keyword">means</span>
    <span class="keyword">for</span> x,y <span class="keyword">st</span> [x,y] <span class="keyword">in</span> (the BinRel <span class="keyword">of</span> D) <span class="keyword">holds</span>
      [f.x,f.y] <span class="keyword">in</span> (the BinRel <span class="keyword">of</span> D);
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> D <span class="keyword">be</span> CPO,
      f <span class="keyword">be</span> Function <span class="keyword">of</span> D,D;

  <span class="keyword">attr</span> f <span class="keyword">is</span> continuous <span class="keyword">means</span>
    f <span class="keyword">is</span> monotone &amp;
    <span class="keyword">for</span> X <span class="keyword">being</span> (the BinRel <span class="keyword">of</span> D)-directed Subset <span class="keyword">of</span> D <span class="keyword">holds</span>
<span class="comment">::&gt;                                      *115</span>
      X=X; <span class="comment">::TODO</span>
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h3>Graph Models</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">definition</span>
  <span class="keyword">let</span> Bn <span class="keyword">be</span> non empty <span class="keyword">set</span>;
  <span class="keyword">func</span> BnNext(Bn) -&gt; <span class="keyword">set</span> <span class="keyword">equals</span> Bn \/ [: Bn*, Bn :];
  <span class="keyword">coherence</span>;
<span class="keyword">end</span>;

<span class="keyword">definition</span>
  <span class="keyword">let</span> A <span class="keyword">be</span> non empty <span class="keyword">set</span>;
  <span class="keyword">func</span> Web(A) -&gt; <span class="keyword">set</span> <span class="keyword">equals</span> A;
  <span class="comment">:: TODO inductive construction</span>
  <span class="keyword">coherence</span>;
<span class="keyword">end</span>;

<span class="keyword">theorem</span>
  <span class="keyword">for</span> A <span class="keyword">being</span> non empty <span class="keyword">set</span> <span class="keyword">holds</span>
    id Web(A) <span class="keyword">is</span> one-to-one
<span class="keyword">proof</span>
  <span class="keyword">thus</span> <span class="keyword">thesis</span>;
<span class="keyword">end</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>What does this registration actually state?</p>
<ol>
<li>For any infinite set $B$, there is some one-to-one function that
 embeds $B^*\times B$ into $B$.</li>
<li>There are at least certain infinite sets $B$ for which
 such an embedding is possible.</li>
</ol>
<p>I only need the second statement, and proving it shouldn&#39;t be too
 much trouble. (It would simply require
 doing the infinite recursive construction of $B=Web(A)$ for some
 non-empty set $A$). I don&#39;t even know for sure if the first
 statement holds.</p>
<p>If the first is the case, then how to I define the second statement
 in Mizar? And how do I then define the graph model struct, below,
 without being able to use the <code>one-to-one</code> adjective?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">registration</span>
  <span class="keyword">let</span> B <span class="keyword">be</span> infinite <span class="keyword">set</span>;
  <span class="keyword">cluster</span> one-to-one <span class="keyword">for</span> Function <span class="keyword">of</span> [:B*,B:],B;
  <span class="comment">:: TODO show that such an embedding is possible, by above construction</span>
  <span class="keyword">existence</span>;
<span class="comment">::&gt;       *4</span>
<span class="keyword">end</span>;

<span class="comment">:: Graph models</span>
<span class="keyword">definition</span>
  <span class="keyword">struct</span> GraphModel (#
    carrier -&gt; infinite <span class="keyword">set</span>,
    c -&gt; one-to-one (Function <span class="keyword">of</span>
      [:(the carrier)*, the carrier:], the carrier)
  #);
<span class="keyword">end</span>;


<span class="comment">::&gt;</span>
<span class="comment">::&gt; 4: This inference is not accepted</span>
<span class="comment">::&gt; 100: Unused locus</span>
<span class="comment">::&gt; 106: Unknown attribute</span>
<span class="comment">::&gt; 115: Unknown attribute</span>
<span class="comment">::&gt; 136: Non registered cluster</span>
<span class="comment">::&gt; 151: Unknown mode format</span>
<span class="comment">::&gt; 175: Unknown attribute format</span></pre></div></div>
            
        </li>
        
    </ul>
  </div>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"], scale: 90 }
  });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
